%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!114 &11400000
MonoBehaviour:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_GameObject: {fileID: 0}
  m_Enabled: 1
  m_EditorHideFlags: 0
  m_Script: {fileID: 11500000, guid: 2eb96458d5d3d8a418388ebad98e1bc4, type: 3}
  m_Name: P3D_Alpha_Bundle
  m_EditorClassIdentifier: 
  title: Paint in 3D/Alpha
  target: {fileID: 4800000, guid: 9f01b1d1d9b572c498cc565d0e530b40, type: 3}
  variantHash: -1901988290
  projectHash: 1665907753
  variants:
  - Pipe: 0
    Code: "//<HASH>-1901988290</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: Standard\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      \n\t[NoScaleOffset]_MainTex(\"Albedo
      (RGB) Alpha (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal
      (RGBA)\", 2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic
      (R) Occlusion (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n  
      }\n   SubShader\n   {\n      Tags { \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"
      }\n\n      \n      \nZWrite Off ColorMask RGB\n\n\n      Pass\n      {\n\t\t  
      Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardBase\" }\n        
      Blend SrcAlpha OneMinusSrcAlpha\n         \n\n         CGPROGRAM\n        
      // compile directives\n            #pragma vertex Vert\n   #pragma fragment
      Frag\n\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n        
      #pragma multi_compile_fog\n         #pragma multi_compile_fwdbase\n        
      #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n        
      #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n\n        
      #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n        
      // -------- variant for: <when no other keywords are defined>\n\n         #include
      \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include
      \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n        
      #define SHADER_PASS SHADERPASS_FORWARD\n         #define _PASSFORWARD 1\n\n        
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n   #define _STANDARD 1\n\n  
      #define _ALPHABLEND_ON 1\n// If your looking in here and thinking WTF, yeah,
      I know. These are taken from the SRPs, to allow us to use the same\n// texturing
      library they use. However, since they are not included in the standard pipeline
      by default, there is no\n// way to include them in and they have to be inlined,
      since someone could copy this shader onto another machine without\n// Better
      Shaders installed. Unfortunate, but I'd rather do this and have a nice library
      for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated
      in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in
      the standard SRP code, but they are in tons of Unity own projects on the web,
      so I grabbed them from there.\n\n\n#if defined(SHADER_API_XBOXONE)\n\t\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n//
      This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight
      copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t//
      This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float
      textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray
      textureName    // no support to _float on Array, it's being added\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)         
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3,
      0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)             
      textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName,
      coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)          
      textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif
      defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)     
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)           
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)            
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define
      TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)        
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)  
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)        
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                   
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)               
      SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define
      TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),  
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              
      TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define
      TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),        
      SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         
      TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif
      defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)          
      TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)    
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type,
      textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type,
      textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type,
      textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type,
      textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define
      SAMPLER(samplerName)                    SamplerState samplerName\n\t#define
      SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define
      TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),        
      SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          
      TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName),
      SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                
      TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),  
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       
      TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName,
      samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                              textureName.Load(int3(unCoord2,
      lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                    
      textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName,
      unCoord2, index)                          textureName.Load(int4(unCoord2, index,
      0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)       
      textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index,
      lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                      
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                              textureName.Load(int4(unCoord3,
      lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName,
      float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName,
      coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)             
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif
      defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 /
      (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define
      asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName)
      #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE
      textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                       
      samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                 
      samplerCUBE textureName // No supoport to textureCubeArray and can't emulate
      with texture2DArray\n\t#define TEXTURE3D(textureName)                         
      sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                   
      sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)             
      TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                 
      samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)           
      TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName)
      // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                  
      samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)            
      TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER
      textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName)
      // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                
      SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)          
      TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define
      RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define
      SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName,
      samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if
      (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName,
      coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t   
      // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName,
      coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0,
      bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx,
      ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                    
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName,
      samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)         
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName,
      samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define
      SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                               
      texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation
      with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3,
      lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName,
      coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3,
      bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                  
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)       
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName,
      samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define
      SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                        
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName,
      samplerName, coord3)                           SHADOW2D_SAMPLE(textureName,
      samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName,
      samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define
      SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                        
      SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName,
      samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t//
      Not supported. Can't define as error because shader library is calling these
      functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                              
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                     
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                            
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                 
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2,
      index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                                              
      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t//
      Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error
      unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef
      UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define
      UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef
      UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#  
      define UNITY_LOOP\n#endif\n\n\n\n#define _USINGTEXCOORD1 1\n\n\n         //
      data across stages, stripped like the above.\n         struct VertexToPixel\n        
      {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n           
      float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n            
      float4 texcoord0 : TEXCOORD3;\n             float4 texcoord1 : TEXCOORD4;\n           
      // float4 texcoord2 : TEXCOORD5;\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // float4 texcoord3 : TEXCOORD6;\n            // #endif\n\n            // #if
      %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n           
      // #endif\n\n            float4 lmap : TEXCOORD8;\n            #if UNITY_SHOULD_SAMPLE_SH\n              
      half3 sh : TEXCOORD9; // SH\n            #endif\n            #ifdef LIGHTMAP_ON\n              
      UNITY_LIGHTING_COORDS(10,11)\n               UNITY_FOG_COORDS(12)\n           
      #else\n               UNITY_FOG_COORDS(10)\n               UNITY_SHADOW_COORDS(11)\n           
      #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4
      vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n           
      // float4 extraV2F0 : TEXCOORD13;\n            // #endif\n\n            //
      #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD14;\n           
      // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4
      extraV2F2 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n           
      // float4 extraV2F3 : TEXCOORD16;\n            // #endif\n\n            //
      #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD17;\n           
      // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4
      extraV2F5 : TEXCOORD18;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n           
      // float4 extraV2F6 : TEXCOORD19;\n            // #endif\n\n            //
      #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD20;\n           
      // #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n        
      };\n\n         \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n              
      #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n              
      #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n              
      #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n              
      #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n              
      #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M  
      unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n              
      #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P    
      OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define
      UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV   
      mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV 
      transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP,
      UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n           
      {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat 
      _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat 
      _UseUV2Alt;\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n        
      {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n          
      UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n           
      o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n          
      // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n          
      // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n          
      // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // #if
      %SCREENPOSREQUIREKEY%\n           // o.screenPos = ComputeScreenPos(o.pos);\n          
      // #endif\n\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n          
      o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz
      = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w
      * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n          
      #ifdef DYNAMICLIGHTMAP_ON\n           o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy
      + unity_DynamicLightmapST.zw;\n           #endif\n           #ifdef LIGHTMAP_ON\n          
      o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n          
      #endif\n\n           // SH/ambient and vertex lights\n           #ifndef LIGHTMAP_ON\n            
      #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n              
      o.sh = 0;\n               // Approximated illumination from non-important point
      lights\n               #ifdef VERTEXLIGHT_ON\n                 o.sh += Shade4PointLights
      (\n                   unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n                  
      unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb,
      unity_LightColor[3].rgb,\n                   unity_4LightAtten0, o.worldPos,
      o.worldNormal);\n               #endif\n               o.sh = ShadeSHPerVertex
      (o.worldNormal, o.sh);\n             #endif\n           #endif // !LIGHTMAP_ON\n\n          
      UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light
      cookie coordinates to pixel shader\n           #ifdef FOG_COMBINED_WITH_TSPACE\n            
      UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to
      pixel shader\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n            
      UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates
      to pixel shader\n           #else\n             UNITY_TRANSFER_FOG(o,o.pos);
      // pass fog coordinates to pixel shader\n           #endif\n\n           return
      o;\n         }\n\n         \n\n         // fragment shader\n         fixed4
      Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out
      float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n           
      , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack
      data\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n          
      #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n          
      #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n          
      ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                
      , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n\n          
      #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n          
      #endif\n\n           \n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n          
      l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha
      = 1;\n\n           ChainSurfaceFunction(l, d);\n\n            \n\n          
      #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          
      #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3
      lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n          
      #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n          
      #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n          
      // compute lighting & shadowing factor\n           UNITY_LIGHT_ATTENUATION(atten,
      IN, d.worldSpacePosition)\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW
      || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                
      SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n             
      #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n             
      o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n             
      o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n             
      #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n             
      #else\n                 SurfaceOutput o;\n              #endif\n\n             
      o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n             
      _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n             
      #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n             
      #else\n                 SurfaceOutputStandard o;\n              #endif\n             
      o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n             
      o.Occlusion = l.Occlusion;\n           #endif\n\n           o.Albedo = l.Albedo;\n          
      o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n           #if _WORLDSPACENORMAL\n             
      o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d,
      l.Normal));\n           #endif\n\n            fixed4 c = 0;\n            //
      Setup lighting environment\n            UnityGI gi;\n            UNITY_INITIALIZE_OUTPUT(UnityGI,
      gi);\n            gi.indirect.diffuse = 0;\n            gi.indirect.specular
      = 0;\n            gi.light.color = _LightColor0.rgb;\n            gi.light.dir
      = lightDir;\n            // Call GI (lightmaps/SH/reflections) lighting function\n           
      UnityGIInput giInput;\n            UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n           
      giInput.light = gi.light;\n            giInput.worldPos = d.worldSpacePosition;\n           
      giInput.worldViewDir = worldViewDir;\n            giInput.atten = atten;\n           
      #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n               giInput.lightmapUV
      = IN.lmap;\n            #else\n               giInput.lightmapUV = 0.0;\n           
      #endif\n            #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n              
      giInput.ambient = IN.sh;\n            #else\n               giInput.ambient.rgb
      = 0.0;\n            #endif\n            giInput.probeHDR[0] = unity_SpecCube0_HDR;\n           
      giInput.probeHDR[1] = unity_SpecCube1_HDR;\n            #if defined(UNITY_SPECCUBE_BLENDING)
      || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n               giInput.boxMin[0]
      = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n           
      #endif\n            #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n               giInput.boxMax[0]
      = unity_SpecCube0_BoxMax;\n               giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n              
      giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n               giInput.boxMin[1]
      = unity_SpecCube1_BoxMin;\n               giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n           
      #endif\n\n            \n\n            #if defined(_OVERRIDE_SHADOWMASK)\n              
      float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n              
      gi.light.color = mulColor;\n               giInput.light.color = mulColor;\n           
      #endif\n\n            #if _UNLIT\n              c.rgb = l.Albedo;\n             
      c.a = l.Alpha;\n            #elif _BDRF3 || _SIMPLELIT\n               LightingBlinnPhong_GI(o,
      giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                 
      gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular
      = l.SpecularGI;\n               #endif\n               c += LightingBlinnPhong
      (o, d.worldSpaceViewDir, gi);\n            #elif _USESPECULAR || _USESPECULARWORKFLOW
      || _SPECULARFROMMETALLIC\n               LightingStandardSpecular_GI(o, giInput,
      gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse
      = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n              
      #endif\n               c += LightingStandardSpecular (o, d.worldSpaceViewDir,
      gi);\n            #else\n               LightingStandard_GI(o, giInput, gi);\n              
      #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                 
      gi.indirect.specular = l.SpecularGI;\n               #endif\n              
      c += LightingStandard (o, d.worldSpaceViewDir, gi);\n            #endif\n\n          
      c.rgb += o.Emission;\n\n           ChainFinalColorForward(l, d, c);\n\n          
      #if !DISABLEFOG\n            UNITY_APPLY_FOG(_unity_fogCoord, c); // apply
      fog\n           #endif\n           \n\n           return c;\n         }\n\n        
      ENDCG\n\n      }\n\n\n      \n      \n\n\t   // ---- forward rendering additive
      lights pass:\n\t   Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\"
      = \"ForwardAdd\" }\n\t\t   ZWrite Off Blend One One\n         Blend SrcAlpha
      One\n         \n\n         CGPROGRAM\n\n            #pragma vertex Vert\n  
      #pragma fragment Frag\n\n         // compile directives\n         #pragma target
      3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n        
      #pragma skip_variants INSTANCING_ON\n         #pragma multi_compile_fwdadd_fullshadows\n        
      #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n        
      #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n        
      #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n\n        
      #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n        
      #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n\n        
      \n\n         #define _PASSFORWARD 1\n         #define _PASSFORWARDADD 1\n\n        
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n   #define _STANDARD 1\n\n  
      #define _ALPHABLEND_ON 1\n// If your looking in here and thinking WTF, yeah,
      I know. These are taken from the SRPs, to allow us to use the same\n// texturing
      library they use. However, since they are not included in the standard pipeline
      by default, there is no\n// way to include them in and they have to be inlined,
      since someone could copy this shader onto another machine without\n// Better
      Shaders installed. Unfortunate, but I'd rather do this and have a nice library
      for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated
      in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in
      the standard SRP code, but they are in tons of Unity own projects on the web,
      so I grabbed them from there.\n\n\n#if defined(SHADER_API_XBOXONE)\n\t\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n//
      This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight
      copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t//
      This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float
      textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray
      textureName    // no support to _float on Array, it's being added\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)         
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3,
      0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)             
      textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName,
      coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)          
      textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif
      defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)     
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)           
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)            
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define
      TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)        
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)  
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)        
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                   
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)               
      SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define
      TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),  
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              
      TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define
      TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),        
      SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         
      TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif
      defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)          
      TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)    
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type,
      textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type,
      textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type,
      textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type,
      textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define
      SAMPLER(samplerName)                    SamplerState samplerName\n\t#define
      SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define
      TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),        
      SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          
      TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName),
      SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                
      TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),  
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       
      TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName,
      samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                              textureName.Load(int3(unCoord2,
      lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                    
      textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName,
      unCoord2, index)                          textureName.Load(int4(unCoord2, index,
      0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)       
      textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index,
      lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                      
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                              textureName.Load(int4(unCoord3,
      lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName,
      float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName,
      coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)             
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif
      defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 /
      (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define
      asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName)
      #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE
      textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                       
      samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                 
      samplerCUBE textureName // No supoport to textureCubeArray and can't emulate
      with texture2DArray\n\t#define TEXTURE3D(textureName)                         
      sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                   
      sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)             
      TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                 
      samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)           
      TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName)
      // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                  
      samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)            
      TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER
      textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName)
      // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                
      SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)          
      TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define
      RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define
      SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName,
      samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if
      (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName,
      coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t   
      // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName,
      coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0,
      bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx,
      ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                    
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName,
      samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)         
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName,
      samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define
      SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                               
      texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation
      with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3,
      lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName,
      coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3,
      bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                  
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)       
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName,
      samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define
      SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                        
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName,
      samplerName, coord3)                           SHADOW2D_SAMPLE(textureName,
      samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName,
      samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define
      SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                        
      SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName,
      samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t//
      Not supported. Can't define as error because shader library is calling these
      functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                              
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                     
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                            
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                 
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2,
      index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                                              
      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t//
      Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error
      unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef
      UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define
      UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef
      UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#  
      define UNITY_LOOP\n#endif\n\n\n\n#define _USINGTEXCOORD1 1\n\n\n         //
      data across stages, stripped like the above.\n         struct VertexToPixel\n        
      {\n            UNITY_POSITION(pos);       // must be named pos because Unity
      does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n           
      float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n            
      float4 texcoord0 : TEXCOORD3;\n             float4 texcoord1 : TEXCOORD4;\n           
      // float4 texcoord2 : TEXCOORD5;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // float4 texcoord3 : TEXCOORD6;\n            // #endif\n            \n           
      // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n           
      // #endif\n\n            UNITY_LIGHTING_COORDS(8,9)\n            UNITY_FOG_COORDS(10)\n\n           
      \n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor
      : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n           
      // float4 extraV2F0 : TEXCOORD11;\n            // #endif\n\n            //
      #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD12;\n           
      // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4
      extraV2F2 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n           
      // float4 extraV2F3 : TEXCOORD14;\n            // #endif\n\n            //
      #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD15;\n           
      // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4
      extraV2F5 : TEXCOORD16;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n           
      // float4 extraV2F6 : TEXCOORD17;\n            // #endif\n\n            //
      #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD18;\n           
      // #endif\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n\n        
      };\n\n         \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n              
      #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n              
      #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n              
      #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n              
      #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n              
      #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M  
      unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n              
      #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P    
      OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define
      UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV   
      mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV 
      transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP,
      UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n           
      {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat 
      _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat 
      _UseUV2Alt;\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n         \n         \n\n         ShaderData
      CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                    
      , bool facing\n                  #endif\n         )\n         {\n           
      ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n           
      d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n           
      d.worldSpaceTangent = normalize(i.worldTangent.xyz);\n            d.tangentSign
      = i.worldTangent.w;\n            float3 bitangent = cross(i.worldTangent.xyz,
      i.worldNormal) * d.tangentSign * -1;\n            \n\n            d.TBNMatrix
      = float3x3(d.worldSpaceTangent, bitangent, d.worldSpaceNormal);\n           
      d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n           
      d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n        
      {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n          
      UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n           
      o.texcoord0 = v.texcoord0;\n            o.texcoord1 = v.texcoord1;\n          
      // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n          
      // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n          
      // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // #if
      %SCREENPOSREQUIREKEY%\n           // o.screenPos = ComputeScreenPos(o.pos);\n          
      // #endif\n\n           o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n          
      o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent.xyz
      = UnityObjectToWorldDir(v.tangent.xyz);\n           fixed tangentSign = v.tangent.w
      * unity_WorldTransformParams.w;\n           o.worldTangent.w = tangentSign;\n\n          
      UNITY_TRANSFER_LIGHTING(o, v.texcoord1.xy); // pass shadow and, possibly, light
      cookie coordinates to pixel shader\n           UNITY_TRANSFER_FOG(o,o.pos);
      // pass fog coordinates to pixel shader\n\n           return o;\n         }\n\n        
      \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n        
      #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n        
      #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n        
      #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n          
      // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n            
      UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n            
      UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n          
      #endif\n\n\n\n           ShaderData d = CreateShaderData(IN\n             
      #if NEED_FACING\n                 , facing\n              #endif\n          
      );\n           Surface l = (Surface)0;\n\n\n           #ifdef _DEPTHOFFSET_ON\n             
      l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5,
      0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion =
      1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n          
      #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          
      #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3
      lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n          
      #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n          
      #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n          
      #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n             
      #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular
      o = (SurfaceOutputStandardSpecular)0;\n              #else\n                
      SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular
      = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness
      = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n             
      #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n             
      #else\n                 SurfaceOutput o;\n              #endif\n\n             
      o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n             
      _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n             
      #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n             
      #else\n                 SurfaceOutputStandard o;\n              #endif\n             
      o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n             
      o.Occlusion = l.Occlusion;\n           #endif\n\n   \n           o.Albedo =
      l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n\n          
      #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n             
      o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n\n\n          
      UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n           half4
      c = 0;\n\n           // Setup lighting environment\n           UnityGI gi;\n          
      UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n          
      gi.indirect.specular = 0;\n           gi.light.color = _LightColor0.rgb;\n          
      gi.light.dir = lightDir;\n           gi.light.color *= atten;\n\n          
      #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask,
      unity_OcclusionMaskSelector));\n               gi.light.color = mulColor;\n           
      #endif\n\n           #if _USESPECULAR\n              c += LightingStandardSpecular
      (o, worldViewDir, gi);\n           #elif _BDRF3 || _SIMPLELIT\n             
      c += LightingBlinnPhong (o, d.worldSpaceViewDir, gi);\n           #else\n             
      c += LightingStandard (o, worldViewDir, gi);\n           #endif\n          
      \n\n           ChainFinalColorForward(l, d, c);\n\n           #if !DISABLEFOG\n           
      UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n           #endif\n          
      #if !_ALPHABLEND_ON\n              UNITY_OPAQUE_ALPHA(c.a);\n           #endif\n          
      \n           return c;\n         }\n\n         ENDCG\n\n      }\n\n      \n     
      \n\t   // ---- meta information extraction pass:\n\t   Pass\n      {\n\t\t  
      Name \"Meta\"\n\t\t   Tags { \"LightMode\" = \"Meta\" }\n\t\t   Cull Off\n\n        
      \n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment
      Frag\n\n         // compile directives\n         #pragma target 3.0\n        
      #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR
      FOG_EXP FOG_EXP2\n         #pragma shader_feature EDITOR_VISUALIZATION\n\n        
      #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n        
      #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n        
      #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n        
      #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n        
      #include \"UnityPBSLighting.cginc\"\n         #include \"UnityMetaPass.cginc\"\n\n        
      #define _PASSMETA 1\n\n         \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n  
      #pragma shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local
      _ _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n  
      #define _STANDARD 1\n\n   #define _ALPHABLEND_ON 1\n// If your looking in here
      and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us
      to use the same\n// texturing library they use. However, since they are not
      included in the standard pipeline by default, there is no\n// way to include
      them in and they have to be inlined, since someone could copy this shader onto
      another machine without\n// Better Shaders installed. Unfortunate, but I'd
      rather do this and have a nice library for texture sampling instead\n// of
      the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely,
      PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but
      they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n\n#if
      defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero
      values.\n\t// Do not exist on some platform, in this case we need to have a
      standard name that call a function that will initialize all parameters to 0\n\t#define
      ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type,
      name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++)
      { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define
      CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName,
      coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)               
      Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName) 
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)         
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)          
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n//
      This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight
      copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t//
      Initialize arbitrary structure with zero values.\n\t// Do not exist on some
      platform, in this case we need to have a standard name that call a function
      that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name)
      name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for
      (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define
      TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define
      TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)         
      Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)   
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                  
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define
      PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName,
      coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2,
      index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)             
      textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)         
      textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t//
      This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define
      TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define
      TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)       
      TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)               
      Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float
      textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray
      textureName    // no support to _float on Array, it's being added\n\t#define
      TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define
      TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)         
      Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)          
      Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)    
      Texture2DArray textureName    // no support to _float on Array, it's being
      added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support
      to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)          
      Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)        
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)      
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)      
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                 
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState
      samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                
      TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),      
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        
      TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define
      TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),        
      SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)             
      textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName,
      coord3, index)                textureName.Sample(samplerName, float4(coord3,
      index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3,
      index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index),
      lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3,
      index, bias)     textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                              
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                      textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)         
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3,
      0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)             
      textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName,
      coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)          
      textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName,
      samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif
      defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)     
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)           
      TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)            
      TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define
      TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define
      TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define
      TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)        
      RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)  
      RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)        
      RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                   
      SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)               
      SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define
      TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),  
      SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              
      TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define
      TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),        
      SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         
      TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define
      TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),      
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                  
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define
      LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2,
      sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                     
      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName,
      unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define
      LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2,
      index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName,
      coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2,
      index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName,
      coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3,
      index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define
      GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif
      defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if
      (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP
      0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t//
      Do not exist on some platform, in this case we need to have a standard name
      that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type,
      name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize)
      { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex]
      = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName,
      samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t//
      Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray
      textureName\n\t#define TEXTURECUBE(textureName)                TextureCube
      textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray
      textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define
      TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define
      TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)         
      TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)   
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no
      support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)          
      TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)    
      TextureCubeArray textureName  // no support to _float on Array, it's being
      added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)    
      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)        
      TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)  
      TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type,
      textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type,
      textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type,
      textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type,
      textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define
      SAMPLER(samplerName)                    SamplerState samplerName\n\t#define
      SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define
      TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),        
      SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          
      TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define
      TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName),
      SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                
      TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define
      TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),  
      SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       
      TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName,
      samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define
      TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                              
      textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod)                      textureName.SampleLevel(samplerName,
      coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define
      SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)               
      textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName,
      samplerName, coord2, index)                  textureName.Sample(samplerName,
      float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName,
      coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2,
      index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName,
      coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2,
      index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName,
      coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2,
      index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName,
      coord3)                             textureName.Sample(samplerName, coord3)\n\t#define
      SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                   
      textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName,
      samplerName, coord3, bias)                  textureName.SampleBias(samplerName,
      coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod) 
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName,
      samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)          
      textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3,
      index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName,
      coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index),
      bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                         
      textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName,
      samplerName, coord3, lod)                 textureName.SampleLevel(samplerName,
      coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName,
      coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy,
      (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName,
      coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy,
      index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName,
      coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz,
      (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName,
      coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz,
      index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                      
      textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName,
      unCoord2, lod)                              textureName.Load(int3(unCoord2,
      lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                    
      textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName,
      unCoord2, index)                          textureName.Load(int4(unCoord2, index,
      0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)       
      textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index,
      lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                      
      textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                              textureName.Load(int4(unCoord3,
      lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName,
      float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName,
      coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName,
      samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3,
      index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)             
      textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName,
      samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName,
      coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)           
      textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif
      defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 /
      (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define
      asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName)
      #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary
      structure with zero values.\n\t// Do not exist on some platform, in this case
      we need to have a standard name that call a function that will initialize all
      parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define
      ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex
      < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture
      util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName,
      coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture
      abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D
      textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE
      textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                       
      samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                 
      samplerCUBE textureName // No supoport to textureCubeArray and can't emulate
      with texture2DArray\n\t#define TEXTURE3D(textureName)                         
      sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                   
      sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)             
      TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                 
      samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)           
      TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define
      TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define
      TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName)
      // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                  
      samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)            
      TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define
      TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define
      TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER
      textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName)
      // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                
      SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)          
      TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define
      RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define
      RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define
      RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define
      SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName,
      samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName,
      samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName,
      samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName,
      samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName,
      samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName,
      samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName,
      samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName,
      samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define
      TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define
      TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define
      TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define
      TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define
      TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define
      TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define
      TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define
      SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if
      (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName,
      coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t   
      // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName,
      samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2,
      lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName,
      coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0,
      bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx,
      ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                    
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName,
      samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)         
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName,
      samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define
      SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                               
      texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation
      with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3,
      lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName,
      coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3,
      bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                  
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName,
      samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define
      SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)       
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName,
      samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define
      SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                        
      ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName,
      samplerName, coord3)                           SHADOW2D_SAMPLE(textureName,
      samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName,
      samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define
      SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                        
      SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName,
      samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t//
      Not supported. Can't define as error because shader library is calling these
      functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                              
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                     
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                            
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                 
      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2,
      index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName,
      unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define
      LOAD_TEXTURE3D(textureName, unCoord3)                                              
      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName,
      unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t//
      Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName,
      samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define
      GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define
      GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define
      GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define
      GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define
      GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define
      GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define
      GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error
      unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef
      UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define
      UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef
      UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#  
      define UNITY_LOOP\n#endif\n\n\n\n#define _USINGTEXCOORD1 1\n\n\n         \n\n        
      // data across stages, stripped like the above.\n         struct VertexToPixel\n        
      {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n           
      float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n            
      float4 texcoord0 : TEXCOORD3;\n             float4 texcoord1 : TEXCOORD4;\n           
      // float4 texcoord2 : TEXCOORD5;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // float4 texcoord3 : TEXCOORD6;\n            // #endif\n\n            // #if
      %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n           
      // #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              float2
      vizUV : TEXCOORD8;\n              float4 lightCoord : TEXCOORD9;\n           
      #endif\n\n            \n            // #if %VERTEXCOLORREQUIREKEY%\n           
      // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if
      %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD10;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4
      extraV2F1 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // float4 extraV2F2 : TEXCOORD12;\n            // #endif\n\n            //
      #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD13;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4
      extraV2F4 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // float4 extraV2F5 : TEXCOORD15;\n            // #endif\n\n            //
      #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD16;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4
      extraV2F7 : TEXCOORD17;\n            // #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n           
      UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n           
      // data describing the user output of a pixel\n            struct Surface\n           
      {\n               half3 Albedo;\n               half Height;\n              
      half3 Normal;\n               half Smoothness;\n               half3 Emission;\n              
      half Metallic;\n               half3 Specular;\n               half Occlusion;\n              
      half SpecularPower; // for simple lighting\n               half Alpha;\n              
      float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z
      is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n              
      half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n              
      half CoatSmoothness;\n               half Anisotropy;\n               half
      IridescenceMask;\n               half IridescenceThickness;\n              
      int DiffusionProfileHash;\n               float SpecularAAThreshold;\n              
      float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI
      to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n              
      float3 BackDiffuseGI;\n               float3 SpecularGI;\n               //
      requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n           
      };\n\n            // Data the user declares in blackboard blocks\n           
      struct Blackboard\n            {\n                \n                float blackboardDummyData;\n           
      };\n\n            // data the user might need, this will grow to be big. But
      easy to strip\n            struct ShaderData\n            {\n              
      float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n              
      float3 localSpaceNormal;\n               float3 localSpaceTangent;\n       
      \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n              
      float3 worldSpaceTangent;\n               float tangentSign;\n\n              
      float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n              
      float4 texcoord0;\n               float4 texcoord1;\n               float4
      texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n              
      float4 screenPos;\n\n               float4 vertexColor;\n               bool
      isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n              
      float4 extraV2F2;\n               float4 extraV2F3;\n               float4
      extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n              
      float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard
      blackboard;\n            };\n\n            struct VertexData\n            {\n              
      #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n              
      #endif\n               float4 vertex : POSITION;\n               float3 normal
      : NORMAL;\n               float4 tangent : TANGENT;\n               float4
      texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not
      in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1
      || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1
      : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2
      || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if
      _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER
      || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 :
      TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2
      || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef UNITY_MATRIX_M\n               #undef UNITY_MATRIX_I_M\n              
      #undef UNITY_MATRIX_V\n               #undef UNITY_MATRIX_I_V\n              
      #undef UNITY_MATRIX_P\n               #undef UNITY_MATRIX_VP\n              
      #undef UNITY_MATRIX_MV\n               #undef UNITY_MATRIX_T_MV\n              
      #undef UNITY_MATRIX_IT_MV\n               #undef UNITY_MATRIX_MVP\n\n              
      #define UNITY_MATRIX_M     unity_ObjectToWorld\n               #define UNITY_MATRIX_I_M  
      unity_WorldToObject\n               #define UNITY_MATRIX_V     unity_MatrixV\n              
      #define UNITY_MATRIX_I_V   unity_MatrixInvV\n               #define UNITY_MATRIX_P    
      OptimizeProjectionMatrix(glstate_matrix_projection)\n               #define
      UNITY_MATRIX_VP    unity_MatrixVP\n               #define UNITY_MATRIX_MV   
      mul(UNITY_MATRIX_V, UNITY_MATRIX_M)\n               #define UNITY_MATRIX_T_MV 
      transpose(UNITY_MATRIX_MV)\n               #define UNITY_MATRIX_IT_MV transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V))\n               #define UNITY_MATRIX_MVP   mul(UNITY_MATRIX_VP,
      UNITY_MATRIX_M)\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n           
      {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M,
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat 
      _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat 
      _UseUV2Alt;\n\n\n\n\n\n\n\n         \n\n         \n\n         \n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n        
      {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n           
      UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n           
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n\n            o.pos = UnityMetaVertexPosition(v.vertex,
      v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n           
      #ifdef EDITOR_VISUALIZATION\n               o.vizUV = 0;\n               o.lightCoord
      = 0;\n               if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n                 
      o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord0.xy, v.texcoord1.xy,
      v.texcoord2.xy, unity_EditorViz_Texture_ST);\n               else if (unity_VisualizationMode
      == EDITORVIZ_SHOWLIGHTMASK)\n               {\n                  o.vizUV =
      v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n                 
      o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(unity_ObjectToWorld, float4(v.vertex.xyz,
      1)));\n               }\n            #endif\n\n\n             o.texcoord0 =
      v.texcoord0;\n             o.texcoord1 = v.texcoord1;\n            // o.texcoord2
      = v.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            //
      o.texcoord3 = v.texcoord3;\n            // #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n           
      // o.vertexColor = v.vertexColor;\n            // #endif\n\n            //
      #if %SCREENPOSREQUIREKEY%\n            // o.screenPos = ComputeScreenPos(o.pos);\n           
      // #endif\n\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n           
      o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent.xyz
      = UnityObjectToWorldDir(v.tangent.xyz);\n            fixed tangentSign = v.tangent.w
      * unity_WorldTransformParams.w;\n            o.worldTangent.w = tangentSign;\n\n           
      return o;\n         }\n\n         \n\n         // fragment shader\n        
      fixed4 Frag (VertexToPixel IN\n         #if NEED_FACING\n            , bool
      facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n        
      {\n            UNITY_SETUP_INSTANCE_ID(IN);\n\n            #ifdef FOG_COMBINED_WITH_TSPACE\n              
      UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n            #elif defined FOG_COMBINED_WITH_WORLD_POS\n              
      UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n            #else\n               UNITY_EXTRACT_FOG(IN);\n           
      #endif\n\n            ShaderData d = CreateShaderData(IN\n               #if
      NEED_FACING\n                 , facing\n              #endif\n            );\n\n           
      Surface l = (Surface)0;\n\n            l.Albedo = half3(0.5, 0.5, 0.5);\n           
      l.Normal = float3(0,0,1);\n            l.Occlusion = 1;\n            l.Alpha
      = 1;\n\n            \n            ChainSurfaceFunction(l, d);\n\n           
      UnityMetaInput metaIN;\n            UNITY_INITIALIZE_OUTPUT(UnityMetaInput,
      metaIN);\n            metaIN.Albedo = l.Albedo;\n            metaIN.Emission
      = l.Emission;\n          \n            #if _USESPECULAR\n               metaIN.SpecularColor
      = l.Specular;\n            #endif\n\n            #ifdef EDITOR_VISUALIZATION\n             
      metaIN.VizUV = IN.vizUV;\n              metaIN.LightCoord = IN.lightCoord;\n           
      #endif\n            return UnityMetaFragment(metaIN);\n         }\n        
      ENDCG\n\n      }\n\n      \n\n\n\n\n\n\n\n   }\n   \n   \n   \n}\n"
    Hash: -1901988290
    Dirty: 0
  - Pipe: 1
    Code: "//<HASH>474806742</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: URP2019\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      \n\t[NoScaleOffset]_MainTex(\"Albedo
      (RGB) Alpha (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal
      (RGBA)\", 2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic
      (R) Occlusion (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n  
      }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\"
      \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" }\n\n      \n     
      \nZWrite Off ColorMask RGB\n\n\n        Pass\n        {\n            Name \"Universal
      Forward\"\n            Tags \n            { \n                \"LightMode\"
      = \"UniversalForward\"\n            }\n            Blend SrcAlpha OneMinusSrcAlpha,
      One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite Off\n\n            \n\n           
      HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n           
      #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma
      exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n           
      #pragma multi_compile_instancing\n        \n            // Keywords\n           
      #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n           
      #pragma multi_compile _ _MAIN_LIGHT_SHADOWS\n            #pragma multi_compile
      _ _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile _ADDITIONAL_LIGHTS_VERTEX
      _ADDITIONAL_LIGHTS _ADDITIONAL_OFF\n            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n           
      #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _
      _MIXED_LIGHTING_SUBTRACTIVE\n\n            // GraphKeywords: <None>\n\n\n           
      #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define SHADER_PASS
      SHADERPASS_FORWARD\n            #define SHADERPASS_FORWARD\n\n            #define
      _PASSFORWARD 1\n\n            \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n  
      #pragma shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local
      _ _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n  
      #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define
      _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1 1\n\n\n            //
      this has to be here or specular color will be ignored. Not in SG code\n           
      #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n           
      // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n       
      \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n\n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n        
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\tfloat4 _Color;\n\tfloat 
      _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2
      _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n         CBUFFER_END\n\n        
      \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST,
      o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n             
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n         \n\n         // fragment shader\n        
      half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n             
      , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n          
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n           Surface l
      = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth
      = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5,
      0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n          
      l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef
      _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          
      #if defined(_USESPECULAR) || _SIMPLELIT\n              float3 specular = l.Specular;\n             
      float metallic = 1;\n           #else   \n              float3 specular = 0;\n             
      float metallic = l.Metallic;\n           #endif\n\n           \n           
      InputData inputData;\n\n            inputData.positionWS = IN.worldPos;\n           
      #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n           
      #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d,
      l.Normal));\n            #endif\n            \n            inputData.viewDirectionWS
      = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                 
      inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                 
      inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n           
      #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n           
      #endif\n\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n           
      inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n            #if
      defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n              
      l.Emission += l.SpecularGI;\n            #else\n               inputData.bakedGI
      = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #endif\n\n           
      #if !_UNLIT\n               #if _SIMPLELIT\n                  half4 color =
      UniversalFragmentBlinnPhong(\n                     inputData,\n                    
      l.Albedo,\n                     float4(specular * l.Smoothness, 0),\n                    
      l.SpecularPower * 128,\n                     l.Emission,\n                    
      l.Alpha);\n                  color.a = l.Alpha;\n               #elif _BAKEDLIT\n                 
      half4 color = color = UniversalFragmentBakedLit(inputData, l.Albedo, l.Alpha,
      normalTS);\n               #else\n                  half4 color = UniversalFragmentPBR(\n                 
      inputData,\n                  l.Albedo,\n                  metallic,\n                 
      specular,\n                  l.Smoothness,\n                  l.Occlusion,\n                 
      l.Emission,\n                  l.Alpha); \n               #endif\n              
      #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n              
      #endif\n\n            #else\n               half4 color = half4(l.Albedo, l.Alpha);\n              
      #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n              
      #endif\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n           
      return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n     
      \n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags
      \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n            
      // Render State\n            Blend One Zero, One Zero\n            Cull Back\n           
      ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n           
      \n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc
      gles\n            #pragma exclude_renderers d3d11_9x\n        \n           
      #define SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n  
      #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define
      _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n\n            // Includes\n            #include
      \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n       
      \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n\n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\tfloat4
      _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3
      _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n           
      CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef
      unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define
      unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST,
      o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n             
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n            \n\n            // fragment shader\n           
      half4 Frag (VertexToPixel IN\n            #if NEED_FACING\n               ,
      bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n           
      {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData
      d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n\n               Surface
      l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n              
      l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n              
      l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n              
      MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n              
      metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n           
      }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n           
      // Name: <None>\n            Tags \n            { \n                \"LightMode\"
      = \"Universal2D\"\n            }\n           \n            // Render State\n           
      Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n           
      ZWrite On\n            // ColorMask: <None>\n\n            \n\n           
      HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n           
      #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma
      exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n       
      \n            #define SHADERPASS_2D\n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define
      _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n       
      \n\n            \n\n                  #undef WorldNormalVector\n      #define
      WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n     
      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n     
      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name)
      TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n\n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\tfloat4
      _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3
      _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n           
      CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef
      unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define
      unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1, v.texcoord2, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD\n              OUTPUT_LIGHTMAP_UV(v.texcoord1, unity_LightmapST,
      o.lightmapUV);\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #ifdef _MAIN_LIGHT_SHADOWS\n             
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n            \n\n            // fragment shader\n           
      half4 Frag (VertexToPixel IN\n            #if NEED_FACING\n               ,
      bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n           
      {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n\n              
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n\n               Surface
      l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n              
      l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n              
      l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n              
      \n               half4 color = half4(l.Albedo, l.Alpha);\n\n              
      return color;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n\n\n\n\n\n\n\n  
      }\n   \n   \n   \n}\n"
    Hash: 474806742
    Dirty: 0
  - Pipe: 2
    Code: "//<HASH>1242847556</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: URP2020\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\",
      2DArray) = \"\" {}\n      \n\t[NoScaleOffset]_MainTex(\"Albedo (RGB) Alpha
      (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal (RGBA)\",
      2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic (R) Occlusion
      (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n  
      }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\"
      \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" }\n\n      \n\n     
      \nZWrite Off ColorMask RGB\n\n\n        Pass\n        {\n            Name \"Universal
      Forward\"\n            Tags \n            { \n                \"LightMode\"
      = \"UniversalForward\"\n            }\n            Cull Back\n            Blend
      One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend
      SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite
      Off\n\n            \n\n            HLSLPROGRAM\n\n               #pragma vertex
      Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n           
      #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n           
      #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n           
      #pragma multi_compile _ DOTS_INSTANCING_ON\n        \n            // Keywords\n           
      #pragma multi_compile _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile
      _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n           
      #pragma multi_compile _ _MAIN_LIGHT_SHADOWS\n            #pragma multi_compile
      _ _MAIN_LIGHT_SHADOWS_CASCADE\n            #pragma multi_compile _ADDITIONAL_LIGHTS_VERTEX
      _ADDITIONAL_LIGHTS _ADDITIONAL_OFF\n            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n           
      #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _
      LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n           
      // GraphKeywords: <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n           
      #define SHADERPASS_FORWARD\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n           
      #define _PASSFORWARD 1\n            \n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define
      _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n            // this has to be here or specular color will be ignored.
      Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n           
      #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n       
      \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n        
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\tfloat4 _Color;\n\tfloat 
      _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2
      _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n         CBUFFER_END\n\n        
      \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n         \n\n         // fragment shader\n        
      half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n             
      , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n          
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n           Surface l
      = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth
      = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5,
      0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n          
      l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef
      _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          
      #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n             
      float metallic = 1;\n           #else   \n              float3 specular = 0;\n             
      float metallic = l.Metallic;\n           #endif\n\n\n            \n          
      \n            InputData inputData;\n\n            inputData.positionWS = IN.worldPos;\n           
      #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n           
      #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d,
      l.Normal));\n            #endif\n\n            inputData.viewDirectionWS =
      SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                 
      inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                 
      inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n           
      #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n           
      #endif\n\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n           
      inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n            #if
      defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n              
      l.Emission += l.SpecularGI;\n            #else\n               inputData.bakedGI
      = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #endif\n           
      inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n           
      #if !_BAKEDLIT\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n\n              
      #if defined(_OVERRIDE_SHADOWMASK)\n                  float4 mulColor = saturate(dot(l.ShadowMask,
      _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n                 
      inputData.shadowMask = mulColor;\n               #endif\n            #endif\n\n           
      #if !_UNLIT\n               #if _SIMPLELIT\n                  half4 color =
      UniversalFragmentBlinnPhong(\n                     inputData,\n                    
      l.Albedo,\n                     float4(specular * l.Smoothness, 0),\n                    
      l.SpecularPower * 128,\n                     l.Emission,\n                    
      l.Alpha);\n                  color.a = l.Alpha;\n               #elif _BAKEDLIT\n                 
      color = UniversalFragmentBakedLit(inputData, l.Albedo, l.Alpha, normalTS);\n              
      #else\n\n                  \n                  SurfaceData surface        
      = (SurfaceData)0;\n                  surface.albedo              = l.Albedo;\n                 
      surface.metallic            = saturate(metallic);\n                  surface.specular           
      = specular;\n                  surface.smoothness          = saturate(l.Smoothness),\n                 
      surface.occlusion           = l.Occlusion,\n                  surface.emission           
      = l.Emission,\n                  surface.alpha               = saturate(l.Alpha);\n                 
      surface.clearCoatMask       = 0;\n                  surface.clearCoatSmoothness
      = 1;\n\n                  #ifdef _CLEARCOAT\n                      surface.clearCoatMask      
      = saturate(l.CoatMask);\n                      surface.clearCoatSmoothness
      = saturate(l.CoatSmoothness);\n                  #endif\n\n                 
      half4 color = UniversalFragmentPBR(inputData, surface);\n\n               #endif\n              
      color.rgb = MixFog(color.rgb, inputData.fogCoord);\n\n            #else\n              
      half4 color = half4(l.Albedo, l.Alpha);\n               \n            #endif\n           
      ChainFinalColorForward(l, d, color);\n\n            return color;\n\n        
      }\n\n         ENDHLSL\n\n      }\n\n\n      \n      \n      \n      \n       
      Pass\n        {\n            Name \"Meta\"\n            Tags \n           
      { \n                \"LightMode\" = \"Meta\"\n            }\n\n            
      // Render State\n            Blend One Zero, One Zero\n            Cull Back\n           
      ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n           
      \n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc
      gles\n            #pragma exclude_renderers d3d11_9x\n        \n           
      #define SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n  
      #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define
      _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n\n            // Includes\n            #include
      \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n       
      \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\tfloat4
      _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3
      _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n           
      CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef
      unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define
      unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n            \n\n            // fragment shader\n           
      half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                 
      , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n           
      {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData
      d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n\n               Surface
      l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n              
      l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n              
      l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n              
      MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n              
      metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n           
      }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n           
      Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\"
      = \"DepthNormals\"\n            }\n    \n            // Render State\n           
      Cull Back\n            Blend One Zero\n            ZTest LEqual\n           
      ZWrite On\n\n            \n\n            HLSLPROGRAM\n\n               #pragma
      vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n           
      #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n           
      #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n           
      #pragma multi_compile _ DOTS_INSTANCING_ON\n        \n            #define SHADERPASS
      SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH 1\n           
      #define _PASSDEPTHNORMALS 1\n\n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define
      _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n            // this has to be here or specular color will be ignored.
      Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n           
      #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n       
      \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n        
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\tfloat4 _Color;\n\tfloat 
      _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2
      _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n         CBUFFER_END\n\n        
      \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         \n         #if _PASSSHADOW\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n         
      #if _PASSSHADOW\n              // Define shadow pass specific clip position
      for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos,
      o.worldNormal, _LightDirection));\n              #if UNITY_REVERSED_Z\n                 
      o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #else\n                 
      o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n              #endif\n         
      #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n          #endif\n\n         
      #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              #if _BAKEDLIT\n                
      half3 vertexLight = 0;\n              #else\n                 half3 vertexLight
      = VertexLighting(o.worldPos, o.worldNormal);\n              #endif\n             
      half fogFactor = ComputeFogFactor(o.pos.z);\n              o.fogFactorAndVertexLight
      = half4(fogFactor, vertexLight);\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n         \n\n         // fragment shader\n        
      half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n             
      , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n          
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n           Surface l
      = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth
      = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5,
      0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n          
      l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef
      _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          
      return float4(PackNormalOctRectEncode(TransformWorldToViewDir(d.worldSpaceNormal,
      true)), 0.0, 0.0);\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n     
      \n\n\n\n\n\n\n      \n\n   }\n   \n   \n   \n}\n"
    Hash: 1242847556
    Dirty: 0
  - Pipe: 3
    Code: "//<HASH>-743105968</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: URP2021\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\",
      2DArray) = \"\" {}\n      \n\t[NoScaleOffset]_MainTex(\"Albedo (RGB) Alpha
      (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal (RGBA)\",
      2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic (R) Occlusion
      (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n  
      }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\"
      \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\" }\n\n      \n\n     
      \nZWrite Off ColorMask RGB\n\n\n        Pass\n        {\n            Name \"Universal
      Forward\"\n            Tags \n            { \n                \"LightMode\"
      = \"UniversalForward\"\n            }\n            Cull Back\n            Blend
      One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend
      SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite
      Off\n\n            \n\n            HLSLPROGRAM\n\n               #pragma vertex
      Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n           
      #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n           
      #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n           
      #pragma instancing_options renderinglayer\n    \n            // Keywords\n           
      #pragma multi_compile _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile
      _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n           
      #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile
      _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n           
      #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS\n           
      #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile
      _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile _ _REFLECTION_PROBE_BOX_PROJECTION\n           
      #pragma multi_compile _ _SHADOWS_SOFT\n            #pragma multi_compile _
      LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n           
      #pragma multi_compile _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n           
      #pragma multi_compile _ _LIGHT_LAYERS\n            #pragma multi_compile _
      DEBUG_DISPLAY\n            #pragma multi_compile _ _LIGHT_COOKIES\n           
      #pragma multi_compile _ _CLUSTERED_RENDERING\n            // GraphKeywords:
      <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define
      VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define _PASSFORWARD 1\n           
      #define _FOG_FRAGMENT 1\n            \n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define
      _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n            // this has to be here or specular color will be ignored.
      Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n           
      #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n           
      \n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n        
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\tfloat4 _Color;\n\tfloat 
      _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2
      _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n         CBUFFER_END\n\n        
      \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n         
      // For some very odd reason, in 2021.2, we can't use Unity's defines, but have
      to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                
      float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n             
      #else\n                 float3 lightDirectionWS = _LightDirection;\n             
      #endif\n              // Define shadow pass specific clip position for Universal\n             
      o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n             
      #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                  
      o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n             
      #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n             
      half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n               
      fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n             
      #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos,
      o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n         \n\n#if _UNLIT\n   #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Unlit.hlsl\" 
      \n#endif\n\n         // fragment shader\n         half4 Frag (VertexToPixel
      IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth
      : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n          
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n           Surface l
      = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth
      = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5,
      0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n          
      l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef
      _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          
      #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n             
      float metallic = 1;\n           #else   \n              float3 specular = 0;\n             
      float metallic = l.Metallic;\n           #endif\n\n\n            \n          
      \n            InputData inputData = (InputData)0;\n\n            inputData.positionWS
      = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS
      = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d,
      l.Normal));\n            #endif\n\n            inputData.viewDirectionWS =
      SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                 
      inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                 
      inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n           
      #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n           
      #endif\n            \n#if _BAKEDLIT\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n           
      inputData.vertexLighting = 0;\n#else\n            InitializeInputDataFog(float4(IN.worldPos,
      1.0), IN.fogFactorAndVertexLight.x);\n            inputData.vertexLighting
      = IN.fogFactorAndVertexLight.yzw;\n#endif    \n\n\n\n            #if defined(_OVERRIDE_BAKEDGI)\n              
      inputData.bakedGI = l.DiffuseGI;\n               l.Emission += l.SpecularGI;\n           
      #elif _BAKEDLIT\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV,
      IN.sh, inputData.normalWS);\n            #else\n               #if defined(DYNAMICLIGHTMAP_ON)\n               
      inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh,
      inputData.normalWS);\n               #else\n                   inputData.bakedGI
      = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n               #endif\n           
      #endif\n            inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n           
      #if !_BAKEDLIT\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n          
      \n               #if defined(_OVERRIDE_SHADOWMASK)\n                  float4
      mulColor = saturate(dot(l.ShadowMask, _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n                 
      inputData.shadowMask = mulColor;\n               #endif\n            #else\n              
      inputData.shadowMask = float4(1,1,1,1);\n            #endif\n\n           
      #if defined(DEBUG_DISPLAY)\n                #if defined(DYNAMICLIGHTMAP_ON)\n                 
      inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                #endif\n               
      #if defined(LIGHTMAP_ON)\n                  inputData.staticLightmapUV = IN.lightmapUV;\n               
      #else\n                  inputData.vertexSH = IN.sh;\n                #endif\n           
      #endif\n\n            #if _WORLDSPACENORMAL\n              float3 normalTS
      = WorldToTangentSpace(d, l.Normal);\n            #else\n              float3
      normalTS = l.Normal;\n            #endif\n\n            SurfaceData surface        
      = (SurfaceData)0;\n            surface.albedo              = l.Albedo;\n           
      surface.metallic            = saturate(metallic);\n            surface.specular           
      = specular;\n            surface.smoothness          = saturate(l.Smoothness),\n           
      surface.occlusion           = l.Occlusion,\n            surface.emission           
      = l.Emission,\n            surface.alpha               = saturate(l.Alpha);\n           
      surface.clearCoatMask       = 0;\n            surface.clearCoatSmoothness =
      1;\n\n            #ifdef _CLEARCOAT\n                  surface.clearCoatMask      
      = saturate(l.CoatMask);\n                  surface.clearCoatSmoothness = saturate(l.CoatSmoothness);\n           
      #endif\n\n            #if !_UNLIT\n               half4 color = half4(l.Albedo,
      l.Alpha);\n               #ifdef _DBUFFER\n                  #if _BAKEDLIT\n                    
      ApplyDecalToBaseColorAndNormal(IN.pos, color, inputData.normalWS);\n                 
      #else\n                     ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n                 
      #endif\n               #endif\n               #if _SIMPLELIT\n                 
      color = UniversalFragmentBlinnPhong(\n                     inputData,\n                    
      surface);\n               #elif _BAKEDLIT\n                  color = UniversalFragmentBakedLit(inputData,
      color.rgb, color.a, normalTS);\n               #else\n                  color
      = UniversalFragmentPBR(inputData, surface);\n               #endif\n\n              
      #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n              
      #endif\n\n            #else // unlit\n               #ifdef _DBUFFER\n                 
      ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n               #endif\n              
      half4 color = UniversalFragmentUnlit(inputData, l.Albedo, l.Alpha);\n              
      #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n              
      #endif\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n           
      return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n     
      \n      \n      \n        Pass\n        {\n            Name \"Meta\"\n           
      Tags \n            { \n                \"LightMode\" = \"Meta\"\n           
      }\n\n             // Render State\n            Blend One Zero, One Zero\n           
      Cull Back\n            ZTest LEqual\n            ZWrite On\n            //
      ColorMask: <None>\n\n            \n\n            HLSLPROGRAM\n\n              
      #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target
      3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers
      d3d11_9x\n        \n            #define SHADERPASS SHADERPASS_META\n           
      #define _PASSMETA 1\n\n\n            \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n  
      #pragma shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local
      _ _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n  
      #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define _ALPHABLEND_ON 1\n#define
      _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1 1\n\n\n\n            //
      Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n\n                 
      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal,
      data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(),
      normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n     
      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n     
      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define
      UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n     
      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n     
      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex,
      sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)   
      SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n     
      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex,
      sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord) 
      SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD
      (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n        
      #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n        
      #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float
      sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data
      across stages, stripped like the above.\n      struct VertexToPixel\n     
      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n        
      float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n         
      float4 texcoord0 : TEXCOORD3;\n          float4 texcoord1 : TEXCOORD4;\n        
      // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n        
      // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n        
      // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n            CBUFFER_START(UnityPerMaterial)\n\n               \n\tfloat4
      _Color;\n\tfloat  _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3
      _Emission;\n\tfloat2 _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n           
      CBUFFER_END\n\n            \n\n            \n\n            #ifdef unity_WorldToObject\n#undef
      unity_WorldToObject\n#endif\n#ifdef unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define
      unity_ObjectToWorld GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n         
      // For some very odd reason, in 2021.2, we can't use Unity's defines, but have
      to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                
      float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n             
      #else\n                 float3 lightDirectionWS = _LightDirection;\n             
      #endif\n              // Define shadow pass specific clip position for Universal\n             
      o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n             
      #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                  
      o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n             
      #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n             
      half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n               
      fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n             
      #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos,
      o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n            \n\n            // fragment shader\n           
      half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                 
      , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n           
      {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData
      d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n\n               Surface
      l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n              
      l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n              
      l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n              
      MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n              
      metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n           
      }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n           
      Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\"
      = \"DepthNormals\"\n            }\n    \n            // Render State\n           
      Cull Back\n            Blend One Zero\n            ZTest LEqual\n           
      ZWrite On\n\n            \n\n            HLSLPROGRAM\n\n               #pragma
      vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n           
      #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n           
      #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n           
      #pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT // forward-only variant\n\n\n           
      #define SHADERPASS SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH
      1\n            #define _PASSDEPTHNORMALS 1\n\n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n   #define _URP 1\n\n   #define _ALPHABLEND_ON 1\n#define
      _ALPHABLEND_ON 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n            // this has to be here or specular color will be ignored.
      Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n           
      #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n       
      \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0
      _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name)
      TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n     
      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n     
      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n        
      float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n        
      float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         
      float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n        
      // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n        
      // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos
      : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n        
      // half4 vertexColor : COLOR;\n         // #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n        
      // float4 extraV2F0 : TEXCOORD12;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n        
      // float4 extraV2F1 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n        
      // float4 extraV2F2 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n        
      // float4 extraV2F3 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n        
      // float4 extraV2F4 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n        
      // float4 extraV2F5 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n        
      // float4 extraV2F6 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n        
      // float4 extraV2F7 : TEXCOORD19;\n         // #endif\n            \n        
      #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n        
      #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD9;\n        
      #endif\n            float4 fogFactorAndVertexLight : TEXCOORD10;\n           
      float4 shadowCoord : TEXCOORD11;\n         #if UNITY_ANY_INSTANCING_ENABLED\n           
      uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n           
      uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n        
      #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED)
      && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n           
      uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n        
      #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n           
      FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n      };\n\n\n        
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n           
      \n         CBUFFER_START(UnityPerMaterial)\n\n            \n\tfloat4 _Color;\n\tfloat 
      _BumpScale;\n\tfloat  _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2
      _Tiling;\n\tfloat  _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n         CBUFFER_END\n\n        
      \n\n         \n\n         #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n         \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n        
      #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData
      v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n          
      UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n          
      UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n          
      ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           
      o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n          
      // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n          
      // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor
      = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs
      vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos
      = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n          
      o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n         
      // For some very odd reason, in 2021.2, we can't use Unity's defines, but have
      to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                
      float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n             
      #else\n                 float3 lightDirectionWS = _LightDirection;\n             
      #endif\n              // Define shadow pass specific clip position for Universal\n             
      o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n             
      #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #else\n                  o.pos.z = max(o.pos.z, o.pos.w * UNITY_NEAR_CLIP_VALUE);\n             
      #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz,
      0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n         
      #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n         
      #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos
      = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n         
      #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n             
      OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n               o.texcoord1.xy
      = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                  
      o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n             
      #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n             
      half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n               
      fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n             
      #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos,
      o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor,
      vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n            
      o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          
      return o;\n         }\n\n\n         \n\n         // fragment shader\n        
      half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n             
      , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n        
      {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n          
      ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                    
      , facing\n                  #endif\n               );\n           Surface l
      = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth
      = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5,
      0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n          
      l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef
      _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n         
      #if defined(_GBUFFER_NORMALS_OCT)\n              float3 normalWS = d.worldSpaceNormal;\n             
      float2 octNormalWS = PackNormalOctQuadEncode(normalWS);           // values
      between [-1, +1], must use fp32 on some platforms\n              float2 remappedOctNormalWS
      = saturate(octNormalWS * 0.5 + 0.5);   // values between [ 0,  1]\n             
      half3 packedNormalWS = PackFloat2To888(remappedOctNormalWS);      // values
      between [ 0,  1]\n              return half4(packedNormalWS, 0.0);\n         
      #else\n              return half4(NormalizeNormalPerPixel(d.worldSpaceNormal),
      0.0);\n          #endif\n\n         \n         }\n\n         ENDHLSL\n\n     
      }\n\n\n      \n\n\n\n\n\n\n      \n\n   }\n   \n   \n   \n}\n"
    Hash: -743105968
    Dirty: 0
  - Pipe: 4
    Code: "//<HASH>408979143</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: HDRP2019\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      \n\t[NoScaleOffset]_MainTex(\"Albedo
      (RGB) Alpha (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal
      (RGBA)\", 2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic
      (R) Occlusion (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n\t[Header(HDRP
      Options)]\n\t[ToggleOff(_TRANSPARENT_WRITES_MOTION_VEC)] _CW_DisableTransparentMV(\"\tDisable
      Transparent Write Motion Vector\", Float) = 0\n\t[ToggleOff(_ENABLE_FOG_ON_TRANSPARENT)]
      _CW_DisableTransparentFog(\"\tDisable Transparent Fog\", Float) = 0\n\t[Toggle(_ADD_PRECOMPUTED_VELOCITY)]
      _CW_AddPrecomputedVelocity(\"\tAdd Precomputed Velocity\", Float) = 0\n\t[Toggle(_DISABLE_DECALS)]
      _CW_DisableDecals(\"\tDisable Decals\", Float) = 0\n\t[Toggle(_DISABLE_SSR)]
      _CW_DisableSSR(\"\tDisable SSR\", Float) = 0\n\t[Toggle(_DISABLE_SSR_TRANSPARENT)]
      _CW_DisableSSRTransparent(\"\tDisable Transparent SSR\", Float) = 0\n\t[KeywordEnum(Off,
      Plane, Sphere, Thin)] _CW_Refraction (\"\tRefraction\", Float) = 0 \n\n\n\n     
      [HideInInspector] _StencilRef(\"Vector1 \", Int) = 0\n      [HideInInspector]
      _StencilWriteMask(\"Vector1 \", Int) = 3\n      [HideInInspector] _StencilRefDepth(\"Vector1
      \", Int) = 0\n      [HideInInspector] _StencilWriteMaskDepth(\"Vector1 \",
      Int) = 32\n      [HideInInspector] _StencilRefMV(\"Vector1 \", Int) = 128\n     
      [HideInInspector] _StencilWriteMaskMV(\"Vector1 \", Int) = 128\n      [HideInInspector]
      _StencilRefDistortionVec(\"Vector1 \", Int) = 64\n      [HideInInspector] _StencilWriteMaskDistortionVec(\"Vector1
      \", Int) = 64\n      [HideInInspector] _StencilWriteMaskGBuffer(\"Vector1 \",
      Int) = 3\n      [HideInInspector] _StencilRefGBuffer(\"Vector1 \", Int) = 2\n     
      [HideInInspector] _ZTestGBuffer(\"Vector1 \", Int) = 4\n      [HideInInspector]
      [ToggleUI] _RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector]
      [ToggleUI] _ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector] _SurfaceType(\"Vector1
      \", Float) = 0\n      [HideInInspector] [ToggleUI] _ZWrite(\"Boolean\", Float)
      = 0\n      [HideInInspector] _TransparentSortPriority(\"Vector1 \", Int) =
      0\n      [HideInInspector] _ZTestDepthEqualForOpaque(\"Vector1 \", Int) = 4\n     
      [HideInInspector] [Enum(UnityEngine.Rendering.CompareFunction)] _ZTestTransparent(\"Vector1\",
      Float) = 4\n      [HideInInspector] [ToggleUI] _TransparentBackfaceEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector] [ToggleUI] _AlphaCutoffEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector] [ToggleUI] _UseShadowThreshold(\"Boolean\",
      Float) = 0\n      [HideInInspector] _BlendMode(\"Float\", Float) = 0\n   }\n  
      SubShader\n   {\n      Tags { \"RenderPipeline\"=\"HDRenderPipeline\" \"RenderPipeline\"
      = \"HDRenderPipeline\" \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"
      }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n           
      Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite
      Off\n            \n        \n            \n            // Stencil setup\n       
      Stencil\n        {\n           WriteMask [_StencilWriteMask]\n           Ref
      [_StencilRef]\n           Comp Always\n           Pass Replace\n        }\n       
      \n            ColorMask [_ColorMaskTransparentVel] 1\n\n            \n           
      \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma
      enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n       
      \n            //#pragma multi_compile_local _ _ALPHATEST_ON\n        \n           
      // #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n            //#pragma
      shader_feature _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local
      _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADDITIVE _BLENDMODE_PRE_MULTIPLY\n       
      \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_FORWARD\n            #define _PASSFORWARD 1\n           
      \n            \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma
      shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _
      _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma
      shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local
      _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma
      shader_feature_local _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma
      shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n            \n            #pragma multi_compile _ DEBUG_DISPLAY\n           
      #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n           
      #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile
      _ SHADOWS_SHADOWMASK\n            #pragma multi_compile DECALS_OFF DECALS_3RT
      DECALS_4RT\n            #pragma multi_compile USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n           
      #pragma multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #define
      REQUIRE_DEPTH_TEXTURE\n            \n\n\n                  // useful conversion
      functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name)
      TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n       
      \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n       
      \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n           
      #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n       
      #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n       
      \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n       
      \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n       
      #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n       
      \n            // Used by SceneSelectionPass\n            int _ObjectId;\n           
      int _PassValue;\n        \n           \n            // data across stages,
      stripped like the above.\n            struct VertexToPixel\n            {\n              
      float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n              
      float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n              
      float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n              
      float4 texcoord2 : TEXCOORD5;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n              
      // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n              
      // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n              
      // float4 vertexColor : COLOR;\n               // #endif\n\n              
      // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               //
      float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n              
      // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n              
      #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n              
      #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n\n\n            \n            \n            // data describing the user
      output of a pixel\n            struct Surface\n            {\n              
      half3 Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n\n           
      CBUFFER_START(UnityPerMaterial)\n               float _StencilRef;\n              
      float _StencilWriteMask;\n               float _StencilRefDepth;\n              
      float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n              
      float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n              
      float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n              
      float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n              
      float _RequireSplitLighting;\n               float _ReceivesSSR;\n              
      float _ZWrite;\n               float _TransparentSortPriority;\n              
      float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n              
      float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n              
      float _UseShadowThreshold;\n\n               \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef
      VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct
      PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS
      vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS
      PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n  
      output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass
      = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n  
      return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n   
      VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n   
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input,
      output, _Time);\n\n\n    // This return the camera relative position (if enable)\n   
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n   
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n   
      output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n   
      output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n   
      output.texcoord2 = input.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n   
      // output.texcoord3 = input.texcoord3;\n    // #endif\n\n    // #if %SCREENPOSREQUIREKEY%\n   
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n   
      // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n    // output.vertexColor
      = input.vertexColor;\n    // #endif\n    return output;\n}\n\n\n#if (SHADERPASS
      == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS
      input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n   
      input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS
      == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original
      unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat
      unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n//
      x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n//
      x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS
      Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n   
      output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n   
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate
      in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n   
      {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n   
      }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy
      * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    //
      OpenGL right now needs to actually use the incoming vertex position\n    //
      so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos
      = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef
      VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef
      VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n   
      output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n   
      // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n   
      output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 =
      inputMesh.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n    // output.vmesh.texcoord3
      = inputMesh.texcoord3;\n    // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n   
      // output.vmesh.vertexColor = inputMesh.vertexColor;\n    // #endif\n\n   
      return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData
      inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n   
      #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n   
      #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n           
      \n\n            \n                FragInputs BuildFragInputs(VertexToPixel
      input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n            \n                    output.positionRWS
      = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld
      = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n        \n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n       
      \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                  
      {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                      
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                      
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n       
      \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                      
      surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                  
      {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                      
      surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha
      = 1.0;\n                   }\n           #else\n                   surfaceData.ior
      = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0,
      1.0);\n                   surfaceData.atDistance = 1.0;\n                  
      surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                  
      // These static material feature allow compile time optimization\n                  
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n          
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n          
      #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                  
      // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n       
      \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n          
      #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                  
      // Require to have setup baseColor\n                   // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n       
      \n                   // tangent-space normal\n                   float3 normalTS
      = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n       
      \n                   // compute world space normal\n                   #if
      !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = normalTS;  \n                   #endif\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                  
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                  
      if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS,
      surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, 
      surfaceData.geomNormalWS, surfaceData);\n                       #else\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                         
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                      
      #endif\n                   }\n           #endif\n        \n                  
      bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n       
      \n                   // By default we use the ambient occlusion with Tri-ace
      trick (apply outside) for specular occlusion.\n                   // If user
      provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                  
      // Just use the value passed through via the slot (not active otherwise)\n          
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                  
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n          
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n          
      #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                  
      surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness,
      fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance,
      surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n          
      #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                  
      {\n                       // TODO: need to update mip info\n                      
      surfaceData.metallic = 0;\n                   }\n        \n                  
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                   // as it can modify attribute
      use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n           #endif\n               }\n        \n              
      void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3
      V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData,
      out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                    
      #if NEED_FACING\n                        , bool facing\n                    
      #endif\n                  )\n               {\n                 // Removed
      since crossfade does not work, probably needs extra material setup.   \n                
      //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select
      CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed
      = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                
      //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                
      //#endif\n        \n                 d = CreateShaderData(m2ps\n                 
      #if NEED_FACING\n                    , facing\n                  #endif\n                
      );\n\n                 \n\n                 l = (Surface)0;\n\n                
      l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                
      l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion
      = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth
      = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth
      = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                    
      //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                    
      l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                    
      l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                
      surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS
      = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                
      float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput,
      surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha,
      bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n\n                 \n\n                 builtinData.emissiveColor
      = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n                 \n                 #if defined(_OVERRIDE_SHADOWMASK)\n                  
      builtinData.shadowMask0 = l.ShadowMask.x;\n                   builtinData.shadowMask1
      = l.ShadowMask.y;\n                   builtinData.shadowMask2 = l.ShadowMask.z;\n                  
      builtinData.shadowMask3 = l.ShadowMask.w;\n                #endif\n       
      \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceDescription.Distortion;\n                    
      //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                    
      builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur
      = 0.0;\n                 #else\n                     builtinData.distortion
      = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                
      #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n               }\n            \n                      \n         
      void Frag(PackedVaryingsToPS packedInput,\n          #ifdef OUTPUT_SPLIT_LIGHTING\n             
      out float4 outColor : SV_Target0,  // outSpecularLighting\n              out
      float4 outDiffuseLighting : SV_Target1,\n              OUTPUT_SSSBUFFER(outSSSBuffer)\n         
      #else\n              out float4 outColor : SV_Target0\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n             
      , out float4 outMotionVec : SV_Target1\n          #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n         
      #endif // OUTPUT_SPLIT_LIGHTING\n          #ifdef _DEPTHOFFSET_ON\n             
      , out float outputDepth : SV_Depth\n          #endif\n          #if NEED_FACING\n           
      , bool facing : SV_IsFrontFace\n          #endif\n          )\n          {\n         
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n              // Init outMotionVector
      here to solve compiler warning (potentially unitialized variable)\n             
      // It is init to the value of forceNoMotion (with 2.0)\n              outMotionVec
      = float4(2.0, 0.0, 0.0, 0.0);\n          #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n             
      FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n              //
      We need to readapt the SS position as our screen space positions are for a
      low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy
      = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor)
      : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy)
      / GetTileSize();\n\n              // input.positionSS is SV_Position\n             
      PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw,
      input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n             
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n             
      SurfaceData surfaceData;\n              BuiltinData builtinData;\n             
      Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(packedInput.vmesh,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n              BSDFData
      bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n             
      PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n             
      outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip
      lighting when doing debug pass because the debug pass is done before lighting
      so some buffers may not be properly initialized potentially causing crashes
      on PS4.\n\n          #ifdef DEBUG_DISPLAY\n              // Init in debug display
      mode to quiet warning\n          #ifdef OUTPUT_SPLIT_LIGHTING\n             
      outDiffuseLighting = 0;\n              ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS,
      outSSSBuffer);\n          #endif\n\n              \n\n              // Same
      code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n             
      //   i==0 -> the size used in the buffer\n              //   i>0  -> the index
      used (0 value means nothing)\n              // The index stored in this buffer
      could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1]
      as only one supported)\n              //   - a property index which is different
      for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n             
      bool viewMaterial = false;\n              int bufferSize = int(_DebugViewMaterialArray[0]);\n             
      if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB
      = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                 
      // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug
      will do nothing if the index is not a known one\n                  for (int
      index = 1; index <= bufferSize; index++)\n                  {\n                     
      int indexMaterialProperty = int(_DebugViewMaterialArray[index]);\n\n                     
      // skip if not really in use\n                      if (indexMaterialProperty
      != 0)\n                      {\n                          viewMaterial = true;\n\n                         
      GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                         
      GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                         
      GetBuiltinDataDebug(indexMaterialProperty, builtinData, result, needLinearToSRGB);\n                         
      GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                         
      GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                     
      }\n                  }\n\n                  // TEMP!\n                  //
      For now, the final blit in the backbuffer performs an sRGB write\n                 
      // So in the meantime we apply the inverse transform to linear data to compensate.\n                 
      if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0,
      result));\n\n                  outColor = float4(result, 1.0);\n             
      }\n\n              if (!viewMaterial)\n              {\n                  if
      (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode
      == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                     
      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData,
      result);\n\n                      outColor = float4(result, 1.0f);\n                 
      }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                 
      {\n                      float4 result = _DebugTransparencyOverdrawWeight *
      float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST,
      TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                 
      }\n                  else\n          #endif\n                  {\n         
      #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags =
      LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                     
      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                     
      float3 diffuseLighting;\n                      float3 specularLighting;\n\n                     
      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                      {\n                        
      LightLoopOutput lightLoopOutput;\n                         LightLoop(V, posInput,
      preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                        
      // Alias\n                         diffuseLighting = lightLoopOutput.diffuseLighting;\n                        
      specularLighting = lightLoopOutput.specularLighting;\n                     
      }\n                      #else\n                      {\n                        
      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, diffuseLighting,
      specularLighting);\n                      }\n                      #endif\n\n                     
      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting
      *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                     
      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                     
      {\n                          outColor = float4(specularLighting, 1.0);\n                         
      outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                     
      }\n                      else\n                      {\n                         
      outColor = float4(diffuseLighting + specularLighting, 1.0);\n                         
      outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData,
      posInput.positionSS, outSSSBuffer);\n          #else\n                     
      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                     
      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n         
      #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n                      VaryingsPassToPS inputPass
      = UnpackVaryingsPassToPS(packedInput.vpass);\n                      bool forceNoMotion
      = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec
      is already initialize at the value of forceNoMotion (see above)\n                     
      if (!forceNoMotion)\n                      {\n                          float2
      motionVec = CalculateMotionVector(inputPass.positionCS, inputPass.previousPositionCS);\n                         
      EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                         
      outMotionVec.zw = 1.0;\n                      }\n          #endif\n                 
      }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n         
      #ifdef _DEPTHOFFSET_ON\n              outputDepth = posInput.deviceDepth;\n         
      #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n      \n     
      Pass\n        {\n            // based on HDLitPass.template\n            Name
      \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n           
      Cull Off\n        \n            \n        \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma
      enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n           
      //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature
      _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _ _BLENDMODE_ALPHA
      _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n        \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n           
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma shader_feature_local
      _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma
      shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local
      _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local
      _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN         \n\n\n   #define _HDRP 1\n#define
      _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n       
      \n\n            \n\n                  // useful conversion functions to make
      surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n       
      \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n       
      \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n           
      #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n       
      #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n       
      \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n       
      \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n       
      #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n       
      \n            // Used by SceneSelectionPass\n            int _ObjectId;\n           
      int _PassValue;\n        \n           \n            // data across stages,
      stripped like the above.\n            struct VertexToPixel\n            {\n              
      float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n              
      float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n              
      float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n              
      float4 texcoord2 : TEXCOORD5;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n              
      // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n              
      // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n              
      // float4 vertexColor : COLOR;\n               // #endif\n\n              
      // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               //
      float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n              
      // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n              
      #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n              
      #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n\n  \n            \n            \n            // data describing the
      user output of a pixel\n            struct Surface\n            {\n              
      half3 Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n\n           
      CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n              
      float _StencilWriteMask;\n               float _StencilRefDepth;\n              
      float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n              
      float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n              
      float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n              
      float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n              
      float _RequireSplitLighting;\n               float _ReceivesSSR;\n              
      float _ZWrite;\n               float _TransparentSortPriority;\n              
      float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n              
      float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n              
      float _UseShadowThreshold;\n\n               \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef
      VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct
      PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS
      vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS
      PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n  
      output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass
      = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n  
      return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n   
      VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n   
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input,
      output, _Time);\n\n\n    // This return the camera relative position (if enable)\n   
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n   
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n   
      output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n   
      output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n   
      output.texcoord2 = input.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n   
      // output.texcoord3 = input.texcoord3;\n    // #endif\n\n    // #if %SCREENPOSREQUIREKEY%\n   
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n   
      // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n    // output.vertexColor
      = input.vertexColor;\n    // #endif\n    return output;\n}\n\n\n#if (SHADERPASS
      == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS
      input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n   
      input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS
      == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original
      unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat
      unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n//
      x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n//
      x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS
      Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n   
      output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n   
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate
      in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n   
      {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n   
      }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy
      * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    //
      OpenGL right now needs to actually use the incoming vertex position\n    //
      so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos
      = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef
      VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef
      VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n   
      output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n   
      // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n   
      output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 =
      inputMesh.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n    // output.vmesh.texcoord3
      = inputMesh.texcoord3;\n    // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n   
      // output.vmesh.vertexColor = inputMesh.vertexColor;\n    // #endif\n\n   
      return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData
      inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n   
      #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n   
      #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n           
      \n\n            \n                FragInputs BuildFragInputs(VertexToPixel
      input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n            \n                    output.positionRWS
      = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld
      = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n        \n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n       
      \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                  
      {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                      
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                      
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n       
      \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                      
      surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                  
      {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                      
      surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha
      = 1.0;\n                   }\n           #else\n                   surfaceData.ior
      = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0,
      1.0);\n                   surfaceData.atDistance = 1.0;\n                  
      surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                  
      // These static material feature allow compile time optimization\n                  
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n          
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n          
      #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                  
      // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n       
      \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n          
      #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                  
      // Require to have setup baseColor\n                   // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n       
      \n                   // tangent-space normal\n                   float3 normalTS
      = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n       
      \n                   // compute world space normal\n                   #if
      !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = normalTS;  \n                   #endif\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                  
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                  
      if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS,
      surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, 
      surfaceData.geomNormalWS, surfaceData);\n                       #else\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                         
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                      
      #endif\n                   }\n           #endif\n        \n                  
      bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n       
      \n                   // By default we use the ambient occlusion with Tri-ace
      trick (apply outside) for specular occlusion.\n                   // If user
      provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                  
      // Just use the value passed through via the slot (not active otherwise)\n          
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                  
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n          
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n          
      #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                  
      surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness,
      fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance,
      surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n          
      #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                  
      {\n                       // TODO: need to update mip info\n                      
      surfaceData.metallic = 0;\n                   }\n        \n                  
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                   // as it can modify attribute
      use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n           #endif\n               }\n        \n              
      void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3
      V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData,
      out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                    
      #if NEED_FACING\n                        , bool facing\n                    
      #endif\n                  )\n               {\n                 // Removed
      since crossfade does not work, probably needs extra material setup.   \n                
      //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select
      CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed
      = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                
      //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                
      //#endif\n        \n                 d = CreateShaderData(m2ps\n                 
      #if NEED_FACING\n                    , facing\n                  #endif\n                
      );\n\n                 \n\n                 l = (Surface)0;\n\n                
      l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                
      l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion
      = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth
      = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth
      = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                    
      //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                    
      l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                    
      l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                
      surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS
      = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                
      float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput,
      surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha,
      bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n\n                 \n\n                 builtinData.emissiveColor
      = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n                 \n                 #if defined(_OVERRIDE_SHADOWMASK)\n                  
      builtinData.shadowMask0 = l.ShadowMask.x;\n                   builtinData.shadowMask1
      = l.ShadowMask.y;\n                   builtinData.shadowMask2 = l.ShadowMask.z;\n                  
      builtinData.shadowMask3 = l.ShadowMask.w;\n                #endif\n       
      \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceDescription.Distortion;\n                    
      //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                    
      builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur
      = 0.0;\n                 #else\n                     builtinData.distortion
      = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                
      #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n               }\n\n\n            float4 Frag(PackedVaryingsToPS
      packedInput\n               #if NEED_FACING\n                  , bool facing
      : SV_IsFrontFace\n               #endif\n\n            ) : SV_Target\n           
      {\n                FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n               
      // input.positionSS is SV_Position\n                PositionInputs posInput
      = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z,
      input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n               
      SurfaceData surfaceData;\n                BuiltinData builtinData;\n               
      Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(packedInput.vmesh,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n                // no
      debug apply during light transport pass\n\n                BSDFData bsdfData
      = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n               
      LightTransportData lightTransportData = GetLightTransportData(surfaceData,
      builtinData, bsdfData);\n\n                // This shader is call two times.
      Once for getting emissiveColor, the other time to get diffuseColor\n               
      // We use unity_MetaFragmentControl to make the distinction.\n               
      float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n               
      {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                   
      // put abs here to silent a warning, no cost, no impact as color is assume
      to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor),
      saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n               
      }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                   
      // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n               
      }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n       
      }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\"
      }\n        \n            ColorMask 0\n\n            \n\n            HLSLPROGRAM\n       
      \n            #pragma target 4.5\n            #pragma only_renderers d3d11
      ps4 xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n       
      \n            #pragma multi_compile_instancing\n \n            //#pragma multi_compile_local
      _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _SURFACE_TYPE_TRANSPARENT\n           
      //#pragma shader_feature_local _ _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n       
      \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENESELECTIONPASS\n           
      #pragma editor_sync_compilation\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #define _PASSSCENESELECT 1\n\n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n        \n            \n        \n                  // useful
      conversion functions to make surface shader code just work\n\n      #define
      UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define
      UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name)
      TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n            #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n       
      \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n       
      \n            // define FragInputs structure\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n               #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\"\n           
      #endif\n\n\n        \n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n       
      #ifdef DEBUG_DISPLAY\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n       
      \n        #if (SHADERPASS == SHADERPASS_FORWARD)\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n       
      \n            #define HAS_LIGHTLOOP\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n       
      #else\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n       
      #endif\n        \n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n       
      \n            // Used by SceneSelectionPass\n            int _ObjectId;\n           
      int _PassValue;\n        \n           \n            // data across stages,
      stripped like the above.\n            struct VertexToPixel\n            {\n              
      float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n              
      float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n              
      float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n              
      float4 texcoord2 : TEXCOORD5;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n              
      // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n              
      // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n              
      // float4 vertexColor : COLOR;\n               // #endif\n\n              
      // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               //
      float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n              
      // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n              
      #if UNITY_ANY_INSTANCING_ENABLED\n                  uint instanceID : INSTANCEID_SEMANTIC;\n              
      #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n      \n  \n            \n            \n            // data describing
      the user output of a pixel\n            struct Surface\n            {\n              
      half3 Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n\n           
      CBUFFER_START(UnityPerMaterial)\n\n               float _StencilRef;\n              
      float _StencilWriteMask;\n               float _StencilRefDepth;\n              
      float _StencilWriteMaskDepth;\n               float _StencilRefMV;\n              
      float _StencilWriteMaskMV;\n               float _StencilRefDistortionVec;\n              
      float _StencilWriteMaskDistortionVec;\n               float _StencilWriteMaskGBuffer;\n              
      float _StencilRefGBuffer;\n               float _ZTestGBuffer;\n              
      float _RequireSplitLighting;\n               float _ReceivesSSR;\n              
      float _ZWrite;\n               float _TransparentSortPriority;\n              
      float _ZTestDepthEqualForOpaque;\n               float _ZTestTransparent;\n              
      float _TransparentBackfaceEnable;\n               float _AlphaCutoffEnable;\n              
      float _UseShadowThreshold;\n\n               \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\nstruct VaryingsToPS\n{\n   VertexToPixel vmesh;\n   #ifdef
      VARYINGS_NEED_PASS\n      VaryingsPassToPS vpass;\n   #endif\n};\n\nstruct
      PackedVaryingsToPS\n{\n   #ifdef VARYINGS_NEED_PASS\n      PackedVaryingsPassToPS
      vpass;\n   #endif\n   VertexToPixel vmesh;\n\n   UNITY_VERTEX_OUTPUT_STEREO\n};\n\nPackedVaryingsToPS
      PackVaryingsToPS(VaryingsToPS input)\n{\n   PackedVaryingsToPS output = (PackedVaryingsToPS)0;\n  
      output.vmesh = input.vmesh;\n   #ifdef VARYINGS_NEED_PASS\n      output.vpass
      = PackVaryingsPassToPS(input.vpass);\n   #endif\n\n   UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n  
      return output;\n}\n\n\n\n\nVertexToPixel VertMesh(VertexData input)\n{\n   
      VertexToPixel output = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(input);\n   
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n\n    \n    ChainModifyVertex(input,
      output, _Time);\n\n\n    // This return the camera relative position (if enable)\n   
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n    float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n    float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n   
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n    output.pos = TransformWorldToHClip(positionRWS);\n   
      output.worldNormal = normalWS;\n    output.worldTangent = tangentWS;\n\n\n   
      output.texcoord0 = input.texcoord0;\n    output.texcoord1 = input.texcoord1;\n   
      output.texcoord2 = input.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n   
      // output.texcoord3 = input.texcoord3;\n    // #endif\n\n    // #if %SCREENPOSREQUIREKEY%\n   
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n   
      // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n    // output.vertexColor
      = input.vertexColor;\n    // #endif\n    return output;\n}\n\n\n#if (SHADERPASS
      == SHADERPASS_DBUFFER_MESH)\nvoid MeshDecalsPositionZBias(inout VaryingsToPS
      input)\n{\n#if defined(UNITY_REVERSED_Z)\n    input.vmesh.pos.z -= _DecalMeshDepthBias;\n#else\n   
      input.vmesh.pos.z += _DecalMeshDepthBias;\n#endif\n}\n#endif\n\n\n#if (SHADERPASS
      == SHADERPASS_LIGHT_TRANSPORT)\n\n// This was not in constant buffer in original
      unity, so keep outiside. But should be in as ShaderRenderPass frequency\nfloat
      unity_OneOverOutputBoost;\nfloat unity_MaxOutputValue;\n\nCBUFFER_START(UnityMetaPass)\n//
      x = use uv1 as raster position\n// y = use uv2 as raster position\nbool4 unity_MetaVertexControl;\n\n//
      x = return albedo\n// y = return normal\nbool4 unity_MetaFragmentControl;\nCBUFFER_END\n\nPackedVaryingsToPS
      Vert(VertexData inputMesh)\n{\n    VaryingsToPS output = (VaryingsToPS)0;\n   
      output.vmesh = (VertexToPixel)0;\n\n    UNITY_SETUP_INSTANCE_ID(inputMesh);\n   
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output.vmesh);\n\n    // Output UV coordinate
      in vertex shader\n    float2 uv = float2(0.0, 0.0);\n\n    if (unity_MetaVertexControl.x)\n   
      {\n        uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n   
      }\n    else if (unity_MetaVertexControl.y)\n    {\n        uv = inputMesh.texcoord2.xy
      * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n    }\n\n    //
      OpenGL right now needs to actually use the incoming vertex position\n    //
      so we create a fake dependency on it here that haven't any impact.\n    output.vmesh.pos
      = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n#ifdef
      VARYINGS_NEED_POSITION_WS\n    output.vmesh.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz);\n#endif\n\n#ifdef
      VARYINGS_NEED_TANGENT_TO_WORLD\n    // Normal is required for triplanar mapping\n   
      output.vmesh.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n   
      // Not required but assign to silent compiler warning\n    output.vmesh.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n#endif\n\n    output.vmesh.texcoord0 = inputMesh.texcoord0;\n   
      output.vmesh.texcoord1 = inputMesh.texcoord1;\n    output.vmesh.texcoord2 =
      inputMesh.texcoord2;\n    // #if %TEXCOORD3REQUIREKEY%\n    // output.vmesh.texcoord3
      = inputMesh.texcoord3;\n    // #endif\n\n    // #if %VERTEXCOLORREQUIREKEY%\n   
      // output.vmesh.vertexColor = inputMesh.vertexColor;\n    // #endif\n\n   
      return PackVaryingsToPS(output);\n}\n#else\n\nPackedVaryingsToPS Vert(VertexData
      inputMesh)\n{\n    VaryingsToPS varyingsType;\n    varyingsType.vmesh = VertMesh(inputMesh);\n   
      #if (SHADERPASS == SHADERPASS_DBUFFER_MESH)\n       MeshDecalsPositionZBias(varyingsType);\n   
      #endif\n    return PackVaryingsToPS(varyingsType);\n}\n\n#endif\n\n\n\n           
      \n\n            \n                FragInputs BuildFragInputs(VertexToPixel
      input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n            \n                    output.positionRWS
      = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld
      = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n        \n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n       
      \n           #ifdef _HAS_REFRACTION\n                   if (_EnableSSRefraction)\n                  
      {\n                       // surfaceData.ior =                       surfaceDescription.RefractionIndex;\n                      
      // surfaceData.transmittanceColor =        surfaceDescription.RefractionColor;\n                      
      // surfaceData.atDistance =                surfaceDescription.RefractionDistance;\n       
      \n                       surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                      
      surfaceDescription.Alpha = 1.0;\n                   }\n                   else\n                  
      {\n                       surfaceData.ior = 1.0;\n                       surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                       surfaceData.atDistance = 1.0;\n                      
      surfaceData.transmittanceMask = 0.0;\n                       surfaceDescription.Alpha
      = 1.0;\n                   }\n           #else\n                   surfaceData.ior
      = 1.0;\n                   surfaceData.transmittanceColor = float3(1.0, 1.0,
      1.0);\n                   surfaceData.atDistance = 1.0;\n                  
      surfaceData.transmittanceMask = 0.0;\n           #endif\n                \n                  
      // These static material feature allow compile time optimization\n                  
      surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n          
      #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n           #endif\n          
      #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_ANISOTROPY\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n           #endif\n                  
      // surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n       
      \n           #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n           #endif\n           #ifdef
      _MATERIAL_FEATURE_SPECULAR_COLOR\n                   surfaceData.materialFeatures
      |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n           #endif\n        \n          
      #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                  
      // Require to have setup baseColor\n                   // Reproduce the energy
      conservation done in legacy Unity. Not ideal but better for compatibility and
      users can unchek it\n                   surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n           #endif\n\n       
      \n                   // tangent-space normal\n                   float3 normalTS
      = float3(0.0f, 0.0f, 1.0f);\n                   normalTS = surfaceDescription.Normal;\n       
      \n                   // compute world space normal\n                   #if
      !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(normalTS,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = normalTS;  \n                   #endif\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n                  
      // surfaceData.tangentWS = TransformTangentToWorld(surfaceDescription.Tangent,
      fragInputs.tangentToWorld);\n        \n           #if HAVE_DECALS\n                  
      if (_EnableDecals)\n                   {\n                       #if VERSION_GREATER_EQUAL(10,2)\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput,  surfaceData.geomNormalWS,
      surfaceDescription.Alpha);\n                          ApplyDecalToSurfaceData(decalSurfaceData, 
      surfaceData.geomNormalWS, surfaceData);\n                       #else\n                         
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, surfaceDescription.Alpha);\n                         
      ApplyDecalToSurfaceData(decalSurfaceData, surfaceData);\n                      
      #endif\n                   }\n           #endif\n        \n                  
      bentNormalWS = surfaceData.normalWS;\n               \n                   surfaceData.tangentWS
      = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n        \n       
      \n                   // By default we use the ambient occlusion with Tri-ace
      trick (apply outside) for specular occlusion.\n                   // If user
      provide bent normal then we process a better term\n           #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                  
      // Just use the value passed through via the slot (not active otherwise)\n          
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                  
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n          
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                  
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n          
      #endif\n        \n           #ifdef _ENABLE_GEOMETRIC_SPECULAR_AA\n                  
      surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness,
      fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance,
      surfaceDescription.SpecularAAThreshold);\n           #endif\n        \n          
      #ifdef DEBUG_DISPLAY\n                   if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                  
      {\n                       // TODO: need to update mip info\n                      
      surfaceData.metallic = 0;\n                   }\n        \n                  
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                   // as it can modify attribute
      use for static lighting\n                   ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n           #endif\n               }\n        \n              
      void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3
      V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData,
      out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                    
      #if NEED_FACING\n                        , bool facing\n                    
      #endif\n                  )\n               {\n                 // Removed
      since crossfade does not work, probably needs extra material setup.   \n                
      //#ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select
      CrossFade transition in LOD group\n                 //    uint3 fadeMaskSeed
      = asuint((int3)(V * _ScreenSize.xyx)); // Quantize V to _ScreenSize values\n                
      //    LODDitheringTransition(fadeMaskSeed, unity_LODFade.x);\n                
      //#endif\n        \n                 d = CreateShaderData(m2ps\n                 
      #if NEED_FACING\n                    , facing\n                  #endif\n                
      );\n\n                 \n\n                 l = (Surface)0;\n\n                
      l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                
      l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion
      = 1;\n\n                 #ifdef _DEPTHOFFSET_ON\n                    l.outputDepth
      = posInput.deviceDepth;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #ifdef _DEPTHOFFSET_ON\n                    posInput.deviceDepth
      = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                    
      //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                    
      l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                    
      l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                
      surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS
      = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                
      float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput,
      surfaceData, bentNormalWS);\n\n                 InitBuiltinData(posInput, l.Alpha,
      bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2,
      builtinData);\n\n                 \n\n                 builtinData.emissiveColor
      = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n                 \n                 #if defined(_OVERRIDE_SHADOWMASK)\n                  
      builtinData.shadowMask0 = l.ShadowMask.x;\n                   builtinData.shadowMask1
      = l.ShadowMask.y;\n                   builtinData.shadowMask2 = l.ShadowMask.z;\n                  
      builtinData.shadowMask3 = l.ShadowMask.w;\n                #endif\n       
      \n                 #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceDescription.Distortion;\n                    
      //builtinData.distortionBlur = surfaceDescription.DistortionBlur;\n                    
      builtinData.distortion = float2(0.0, 0.0);\n                     builtinData.distortionBlur
      = 0.0;\n                 #else\n                     builtinData.distortion
      = float2(0.0, 0.0);\n                     builtinData.distortionBlur = 0.0;\n                
      #endif\n        \n                   PostInitBuiltinData(V, posInput, surfaceData,
      builtinData);\n               }\n        \n\n            \n            void
      Frag(  PackedVaryingsToPS packedInput\n            #ifdef WRITE_NORMAL_BUFFER\n           
      , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n               
      , out float1 depthColor : SV_Target1\n                #endif\n            #elif
      defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER
      it mean we are Unlit and only need depth, but we still have normal buffer binded\n           
      , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor
      : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            ,
      out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef
      _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n           
      #endif\n            #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n           
      #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(packedInput);\n            
      FragInputs input = BuildFragInputs(packedInput.vmesh);\n\n             // input.positionSS
      is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy,
      _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n            
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n           
      SurfaceData surfaceData;\n            BuiltinData builtinData;\n           
      Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(packedInput.vmesh,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n            
      outputDepth = posInput.deviceDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n            
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS,
      outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In
      case we are rendering in MSAA, reading the an MSAA depth buffer is way too
      expensive. To avoid that, we export the depth to a color buffer\n            
      depthColor = packedInput.vmesh.pos.z;\n             #endif\n         #elif
      defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n            
      // Due to the binding order of these two render targets, we need to have them
      both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n            
      // In case we are rendering in MSAA, reading the an MSAA depth buffer is way
      too expensive. To avoid that, we export the depth to a color buffer\n            
      depthColor = packedInput.vmesh.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n            
      // We use depth prepass for scene selection in the editor, this code allow
      to output the outline correctly\n             outColor = float4(_ObjectId,
      _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n    
      }\n\n        \n      \n      \n\n\n\n\n\n\n\n\n\n   }\n   \n   \n   \n}\n"
    Hash: 408979143
    Dirty: 0
  - Pipe: 5
    Code: "//<HASH>1733683441</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: HDRP2020\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      \n\t[NoScaleOffset]_MainTex(\"Albedo
      (RGB) Alpha (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal
      (RGBA)\", 2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic
      (R) Occlusion (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n\t[Header(HDRP
      Options)]\n\t[ToggleOff(_TRANSPARENT_WRITES_MOTION_VEC)] _CW_DisableTransparentMV(\"\tDisable
      Transparent Write Motion Vector\", Float) = 0\n\t[ToggleOff(_ENABLE_FOG_ON_TRANSPARENT)]
      _CW_DisableTransparentFog(\"\tDisable Transparent Fog\", Float) = 0\n\t[Toggle(_ADD_PRECOMPUTED_VELOCITY)]
      _CW_AddPrecomputedVelocity(\"\tAdd Precomputed Velocity\", Float) = 0\n\t[Toggle(_DISABLE_DECALS)]
      _CW_DisableDecals(\"\tDisable Decals\", Float) = 0\n\t[Toggle(_DISABLE_SSR)]
      _CW_DisableSSR(\"\tDisable SSR\", Float) = 0\n\t[Toggle(_DISABLE_SSR_TRANSPARENT)]
      _CW_DisableSSRTransparent(\"\tDisable Transparent SSR\", Float) = 0\n\t[KeywordEnum(Off,
      Plane, Sphere, Thin)] _CW_Refraction (\"\tRefraction\", Float) = 0 \n\n\n\n     
      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\",
      Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n     
      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\",
      Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\",
      Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n     
      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) =
      1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float)
      = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\",
      Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int)
      = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\",
      Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float)
      = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\",
      Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float)
      = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\",
      Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n     
      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\",
      Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n     
      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\",
      Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) =
      14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\",
      Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float)
      = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\",
      Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\",
      2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"
      = \"HDRenderPipeline\" \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"
      }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n           
      Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite
      Off\n            \n            Stencil\n            {\n               WriteMask
      [_StencilWriteMask]\n               Ref [_StencilRef]\n               CompFront
      Always\n               PassFront Replace\n               CompBack Always\n              
      PassBack Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel]
      1\n\n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n\n\n           
      //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma
      shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile
      _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n           
      //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local
      _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n           
      #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile
      _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n           
      #pragma multi_compile DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma
      multi_compile SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #pragma multi_compile
      SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n            #pragma multi_compile
      USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            //#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n        \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n           
      #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n           
      #define _PASSFORWARD 1\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET
      SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n           
      #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n\n         
      void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                 
      out float4 outColor : SV_Target0,  // outSpecularLighting\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback
      : VT_BUFFER_TARGET,\n                  #endif\n                  out float4
      outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n             
      #else\n                  out float4 outColor : SV_Target0\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback
      : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                    
      , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif //
      _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n             
      #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n             
      #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n             
      #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                
      // Init outMotionVector here to solve compiler warning (potentially unitialized
      variable)\n                 // It is init to the value of forceNoMotion (with
      2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n             
      #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n             
      FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt
      the SS position as our screen space positions are for a low res buffer, but
      we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering
      > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n             
      uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n             
      // input.positionSS is SV_Position\n              PositionInputs posInput =
      GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w,
      input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n             
      SurfaceData surfaceData;\n              BuiltinData builtinData;\n             
      Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n            \n\n             
      BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n             
      PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n             
      outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip
      lighting when doing debug pass because the debug pass is done before lighting
      so some buffers may not be properly initialized potentially causing crashes
      on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug
      display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                   
      outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData,
      posInput.positionSS, outSSSBuffer);\n                #endif\n\n             
      \n\n              // Same code in ShaderPassForwardUnlit.shader\n             
      // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size
      used in the buffer\n              //   i>0  -> the index used (0 value means
      nothing)\n              // The index stored in this buffer could either be\n             
      //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only
      one supported)\n              //   - a property index which is different for
      each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n             
      bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n             
      if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB
      = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                 
      // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug
      will do nothing if the index is not a known one\n                  for (int
      index = 1; index <= bufferSize; index++)\n                  {\n                     
      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                     
      // skip if not really in use\n                      if (indexMaterialProperty
      != 0)\n                      {\n                          viewMaterial = true;\n\n                         
      GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                         
      GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                         
      GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                         
      GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                         
      GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                     
      }\n                  }\n\n                  // TEMP!\n                  //
      For now, the final blit in the backbuffer performs an sRGB write\n                 
      // So in the meantime we apply the inverse transform to linear data to compensate.\n                 
      if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0,
      result));\n\n                  outColor = float4(result, 1.0);\n             
      }\n\n              if (!viewMaterial)\n              {\n                  if
      (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode
      == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                     
      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData,
      result);\n\n                      outColor = float4(result, 1.0f);\n                 
      }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                 
      {\n                      float4 result = _DebugTransparencyOverdrawWeight *
      float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST,
      TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                 
      }\n                  else\n          #endif\n                  {\n         
      #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags =
      LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                     
      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                     
      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput,
      preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                     
      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                     
      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                     
      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting
      *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                     
      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                     
      {\n                          outColor = float4(specularLighting, 1.0);\n                         
      outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                     
      }\n                      else\n                      {\n                         
      outColor = float4(diffuseLighting + specularLighting, 1.0);\n                         
      outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData,
      posInput.positionSS, outSSSBuffer);\n          #else\n                     
      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                     
      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n         
      #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion
      = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec
      is already initialize at the value of forceNoMotion (see above)\n                     
      if (!forceNoMotion)\n                      {\n                          float2
      motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                         
      EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                         
      outMotionVec.zw = 1.0;\n                      }\n          #endif\n                 
      }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n         
      #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n         
      #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback
      = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n           
      ENDHLSL\n        }\n      \n      \n      \n      \n              Pass\n       
      {\n            // based on HDLitPass.template\n            Name \"META\"\n           
      Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n       
      \n            \n        \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 ps4 xboxone vulkan metal switch\n            //#pragma
      enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n\n           
      //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n           
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma shader_feature_local
      _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma
      shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local
      _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local
      _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN         \n\n\n   #define _HDRP 1\n#define
      _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n       
      \n\n            \n\n                  // useful conversion functions to make
      surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n\n  \n            \n            \n            // data describing the user
      output of a pixel\n            struct Surface\n            {\n              
      half3 Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                 
      , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n           
      {\n                FragInputs input = BuildFragInputs(v2f);\n\n               
      // input.positionSS is SV_Position\n                PositionInputs posInput
      = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z,
      input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n               
      SurfaceData surfaceData;\n                BuiltinData builtinData;\n               
      Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n                // no
      debug apply during light transport pass\n\n                BSDFData bsdfData
      = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n               
      LightTransportData lightTransportData = GetLightTransportData(surfaceData,
      builtinData, bsdfData);\n\n                // This shader is call two times.
      Once for getting emissiveColor, the other time to get diffuseColor\n               
      // We use unity_MetaFragmentControl to make the distinction.\n               
      float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n               
      {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                   
      // put abs here to silent a warning, no cost, no impact as color is assume
      to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor),
      saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n               
      }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                   
      // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n               
      }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n       
      }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\"
      }\n        \n            Cull Off\n            ColorMask 0\n\n            \n\n           
      HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma
      only_renderers d3d11 playstation xboxone vulkan metal switch\n            #pragma
      multi_compile_instancing\n            #pragma editor_sync_compilation\n           
      #pragma instancing_options renderinglayer\n        \n            //#pragma
      shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local
      _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local
      _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n           
      #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n           
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma shader_feature_local
      _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma
      shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local
      _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local
      _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN         \n\n\n   #define _HDRP 1\n#define
      _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n       
      \n            \n\n        \n                  // useful conversion functions
      to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name)
      TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n  \n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n        \n\n            \n            void Frag(  VertexToPixel IN\n           
      #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n               
      #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n               
      #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH
      is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth,
      but we still have normal buffer binded\n            , out float4 outNormalBuffer
      : SV_Target0\n            , out float1 depthColor : SV_Target1\n           
      #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n           
      #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth
      : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n            
      UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input
      = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n            
      PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw,
      input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n\n            
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n           
      SurfaceData surfaceData;\n            BuiltinData builtinData;\n           
      Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n            
      outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n            
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS,
      outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In
      case we are rendering in MSAA, reading the an MSAA depth buffer is way too
      expensive. To avoid that, we export the depth to a color buffer\n            
      depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH)
      // When we are MSAA depth only without normal buffer\n             // Due to
      the binding order of these two render targets, we need to have them both declared\n            
      outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are
      rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To
      avoid that, we export the depth to a color buffer\n             depthColor
      = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We
      use depth prepass for scene selection in the editor, this code allow to output
      the outline correctly\n             outColor = float4(_ObjectId, _PassValue,
      1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n       
      \n              Pass\n        {\n            Name \"ScenePickingPass\"\n           
      Tags\n            {\n               \"LightMode\" = \"Picking\"\n           
      }\n            \n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n           
      #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature
      _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF
      _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma
      shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local
      _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local
      _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _
      _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n           
      #pragma multi_compile _ WRITE_DECAL_BUFFER\n        \n\n            #define
      SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n           
      \n            \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma
      shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _
      _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma
      shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local
      _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma
      shader_feature_local _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma
      shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n   
      \n\n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n            void Frag( VertexToPixel v2f\n                         
      #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                         
      , out float4 outColor : SV_Target0\n                          #else\n                         
      #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color
      as SV_Target0 for alpha to coverage\n                            , out float4
      depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                               
      , out float4 outNormalBuffer : SV_Target1\n                               
      #endif\n                            #else\n                               
      #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer
      : SV_Target0\n                                #endif\n                           
      #endif\n\n                            // Decal buffer must be last as it is
      bind but we can optionally write into it (based on _DISABLE_DECALS)\n                           
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                           
      , out float4 outDecalBuffer : SV_TARGET_DECAL\n                           
      #endif\n                        #endif\n                        #if NEED_FACING\n                          
      , bool facing : SV_IsFrontFace\n                        #endif\n\n                     
      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                 
      FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS
      is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy,
      _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                 
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                 
      SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                 
      Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n\n                  \n                 
      #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for
      scene selection in the editor, this code allow to output the outline correctly\n                     
      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif
      defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                 
      #else\n                     #ifdef WRITE_MSAA_DEPTH\n                      
      // In case we are rendering in MSAA, reading the an MSAA depth buffer is way
      too expensive. To avoid that, we export the depth to a color buffer\n                      
      depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                         
      // Alpha channel is used for alpha to coverage\n                          depthColor.a
      = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                      
      #endif // alphatomask\n                     #endif // msaa_depth\n                 
      \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                       
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                    
      #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                       
      DecalPrepassData decalPrepassData;\n                        // We don't have
      the right to access SurfaceData in a shaderpass.\n                        //
      However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData()
      to every Material to return geomNormalWS anyway\n                        //
      Here we will put the constrain that any Material requiring to support Decal,
      will need to have geomNormalWS as member of surfaceData (and we already require
      normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                       
      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                       
      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                    
      #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n       
      }\n\n              Pass\n        {\n            Name \"MotionVectors\"\n           
      Tags\n            {\n               \"LightMode\" = \"MotionVectors\"\n           
      }\n    \n            // Render State\n            Cull Back\n            ZWrite
      On\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskMV]\n                 
      Ref [_StencilRefMV]\n                  CompFront Always\n                 
      PassFront Replace\n                  CompBack Always\n                  PassBack
      Replace\n               }\n\n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n\n\n           
      #pragma multi_compile _ WRITE_MSAA_DEPTH\n            //#pragma shader_feature
      _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF
      _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma
      shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local
      _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local
      _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n           
      //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local
      _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n           
      #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n        \n\n            #define SHADERPASS SHADERPASS_MOTION_VECTORS\n           
      #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define VARYINGS_NEED_PASS\n           
      #define _PASSMOTIONVECTOR 1\n\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n#define
      SV_TARGET_NORMAL SV_Target3\n#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n#define
      SV_TARGET_NORMAL SV_Target2\n#else\n#define SV_TARGET_NORMAL SV_Target1\n#endif\n\n//
      Caution: Motion vector pass is different from Depth prepass, it render normal
      buffer last instead of decal buffer last\n// and thus, we force a write of
      0 if _DISABLE_DECALS so we always write in the decal buffer.\n// This is required
      as we can't make distinction  between deferred (write normal buffer) and forward
      (write normal buffer)\n// in the context of the motion vector pass. The cost
      is acceptable as it is only do object with motion vector (usualy skin object)\n//
      that most of the time use Forward Material (so are already writing motion vector
      data).\n// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)\nvoid
      Frag(  VertexToPixel v2f\n            #ifdef WRITE_MSAA_DEPTH\n           
      // We need the depth color as SV_Target0 for alpha to coverage\n           
      , out float4 depthColor : SV_Target0\n            , out float4 outMotionVector
      : SV_Target1\n                #ifdef WRITE_DECAL_BUFFER\n                ,
      out float4 outDecalBuffer : SV_Target2\n                #endif\n           
      #else\n            // When no MSAA, the motion vector is always the first buffer\n           
      , out float4 outMotionVector : SV_Target0\n                #ifdef WRITE_DECAL_BUFFER\n               
      , out float4 outDecalBuffer : SV_Target1\n                #endif\n           
      #endif\n\n            // Decal buffer must be last as it is bind but we can
      optionally write into it (based on _DISABLE_DECALS)\n            #ifdef WRITE_NORMAL_BUFFER\n           
      , out float4 outNormalBuffer : SV_TARGET_NORMAL\n            #endif\n\n           
      #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n           
      #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n           
      #endif\n        )\n          {\n\n              FragInputs input = BuildFragInputs(v2f);\n             
      PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw,
      input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n             
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n             
      SurfaceData surfaceData;\n              BuiltinData builtinData;\n             
      Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n            #ifdef _DEPTHOFFSET_ON\n               
      v2f.motionVectorCS.w += builtinData.depthOffset;\n                v2f.previousPositionCS.w
      += builtinData.depthOffset;\n            #endif\n\n             // TODO: How
      to allow overriden motion vector from GetSurfaceAndBuiltinData ?\n            
      float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);\n\n            
      // Convert from Clip space (-1..1) to NDC 0..1 space.\n             // Note
      it doesn't mean we don't have negative value, we store negative or positive
      offset in NDC space.\n             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS
      * 0.5 + 0.5)) = (motionVector * 0.5)\n             EncodeMotionVector(motionVector
      * 0.5, outMotionVector);\n\n             // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n             bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n\n             // Setting the motionVector to a value more than 2
      set as a flag for \"force no motion\". This is valid because, given that the
      velocities are in NDC,\n             // a value of >1 can never happen naturally,
      unless explicitely set. \n             if (forceNoMotion)\n                
      outMotionVector = float4(2.0, 0.0, 0.0, 0.0);\n\n         // Depth and Alpha
      to coverage\n         #ifdef WRITE_MSAA_DEPTH\n             // In case we are
      rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To
      avoid that, we export the depth to a color buffer\n             depthColor
      = v2f.pos.z;\n\n             #ifdef _ALPHATOMASK_ON\n             // Alpha
      channel is used for alpha to coverage\n             depthColor.a = SharpenAlpha(builtinData.opacity,
      builtinData.alphaClipTreshold);\n             #endif\n         #endif\n\n        
      // Normal Buffer Processing\n         #ifdef WRITE_NORMAL_BUFFER\n            
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n        
      #endif\n\n         #if defined(WRITE_DECAL_BUFFER)\n             DecalPrepassData
      decalPrepassData;\n             // Force a write in decal buffer even if decal
      is disab. This is a neutral value which have no impact for later pass\n            
      #ifdef _DISABLE_DECALS\n             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n            
      #else\n             // We don't have the right to access SurfaceData in a shaderpass.\n            
      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData()
      to every Material to return geomNormalWS anyway\n             // Here we will
      put the constrain that any Material requiring to support Decal, will need to
      have geomNormalWS as member of surfaceData (and we already require normalWS
      anyway)\n             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n            
      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n            
      #endif\n             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n        
      #endif\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n        
      #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n             
      Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n           
      {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n           
      // Render State\n            Cull Back\n            ZTest LEqual\n           
      ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n\n\n\n           
      //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma
      shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local
      _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n           
      #define _PASSFULLSCREENDEBUG 1\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n         \n            #ifdef
      RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n           
      #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n   
      \n\n\n\n            // If we use subsurface scattering, enable output split
      lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING)
      && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n    \n            // Translate
      transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n\n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex);\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // copy before user modification, since we'll apply that to the copy later\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n\n           
      \n            previousMesh.vertex = float4(effectivePositionOS, 1);\n           
      VertexToPixel dummy = (VertexToPixel)0;\n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n           
      // we might need this for skinned objects?\n            //float3 normalWS =
      TransformPreviousObjectToWorldNormal(input.normal).xyz;\n\n            #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || (_PASSFORWARD && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n                    #if defined(_ENABLE_SHADOW_MATTE)
      && SHADERPASS == SHADERPASS_FORWARD_UNLIT\n                        HDShadowContext
      shadowContext = InitShadowContext();\n                        float shadow;\n                       
      float3 shadow3;\n                        // We need to recompute some coordinate
      not computed by default for shadow matte\n                        posInput
      = GetPositionInput(fragInputs.positionSS.xy, _ScreenSize.zw, fragInputs.positionSS.z,
      UNITY_MATRIX_I_VP, GetWorldToViewMatrix());\n                        float3
      upWS = normalize(fragInputs.tangentToWorld[1]);\n                        uint
      renderingLayers = GetMeshRenderingLightLayer();\n                        ShadowLoopMin(shadowContext,
      posInput, upWS, asuint(_ShadowMatteFilter), renderingLayers, shadow3);\n                       
      shadow = dot(shadow3, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));\n               
      \n                        float4 shadowColor = (1.0 - shadow) * surfaceDescription.ShadowTint.rgba;\n                       
      float  localAlpha  = saturate(shadowColor.a + surfaceDescription.Alpha);\n               
      \n                        // Keep the nested lerp\n                       
      // With no Color (bsdfData.color.rgb, bsdfData.color.a == 0.0f), just use ShadowColor*Color
      to avoid a ring of \"white\" around the shadow\n                        //
      And mix color to consider the Color & ShadowColor alpha (from texture or/and
      color picker)\n                        #ifdef _SURFACE_TYPE_TRANSPARENT\n                           
      surfaceData.baseColor = lerp(shadowColor.rgb * surfaceData.baseColor, lerp(lerp(shadowColor.rgb,
      surfaceData.baseColor, 1.0 - surfaceDescription.ShadowTint.a), surfaceData.baseColor,
      shadow), surfaceDescription.Alpha);\n                        #else\n                           
      surfaceData.baseColor = lerp(lerp(shadowColor.rgb, surfaceData.baseColor, 1.0
      - surfaceDescription.ShadowTint.a), surfaceData.baseColor, shadow);\n                       
      #endif\n                        localAlpha = ApplyBlendMode(surfaceData.baseColor,
      localAlpha).a;\n                \n                        surfaceDescription.Alpha
      = localAlpha;\n                    #endif\n\n                    // These static
      material feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                
      //builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;\n       
      \n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                    
      //builtinData.distortion = surfaceData.Distortion;\n                     //builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include
      \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n        
      #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading
      debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel
      v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n           
      #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n            
      FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput
      = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z,
      input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n            
      if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n            
      {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n            
      }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n\n\n\n\n\n\n     
      \n   }\n\n   \n   \n   \n}\n"
    Hash: 1733683441
    Dirty: 0
  - Pipe: 6
    Code: "//<HASH>-395843100</HASH>\n////////////////////////////////////////\n//
      Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand
      edit!\n//\n//   Unity Version: 2019.4.12f1\n//   Render Pipeline: HDRP2021\n//  
      Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader
      \"Paint in 3D/Alpha\"\n{\n   Properties\n   {\n      \n\t[NoScaleOffset]_MainTex(\"Albedo
      (RGB) Alpha (A)\", 2D) = \"white\" {}\n\t[NoScaleOffset][Normal]_BumpMap(\"Normal
      (RGBA)\", 2D) = \"bump\" {}\n\t[NoScaleOffset]_MetallicGlossMap(\"Metallic
      (R) Occlusion (G) Smoothness (B)\", 2D) = \"white\" {}\n\t[NoScaleOffset]_EmissionMap(\"Emission
      (RGB)\", 2D) = \"white\" {}\n\n\t_Color(\"Color\", Color) = (1,1,1,1)\n\t_BumpScale(\"Normal
      Map Strength\", Range(0,5)) = 1\n\t_Metallic(\"Metallic\", Range(0,1)) = 0\n\t_GlossMapScale(\"Smoothness\",
      Range(0,1)) = 1\n\t_Emission(\"Emission\", Color) = (0,0,0)\n\t_Tiling(\"Tiling
      (XY)\", Vector) = (1,1,0,0)\n\t[Toggle(_USE_UV2)] _UseUV2(\"Use Second UV\",
      Float) = 0\n\n\t[Header(OVERRIDE SETTINGS)]\n\t[Toggle(_USE_UV2_ALT)] _UseUV2Alt(\"\tUse
      Second UV\", Float) = 1\n\t[Toggle(_OVERRIDE_OPACITY)] _EnableOpacity(\"\tEnable
      Opacity\", Float) = 0\n\t[Toggle(_OVERRIDE_NORMAL)] _EnableNormal(\"\tEnable
      Normal\", Float) = 0\n\t[Toggle(_OVERRIDE_MOS)] _EnableMos(\"\tEnable MOS\",
      Float) = 0\n\t[Toggle(_OVERRIDE_EMISSION)] _EnableEmission(\"\tEnable Emission\",
      Float) = 0\n\n\t[Header(OVERRIDES)]\n\t[NoScaleOffset]_AlbedoTex(\"\tPremultiplied
      Albedo (RGB) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_OpacityTex(\"\tPremultiplied
      Opacity (R) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_NormalTex(\"\tPremultiplied
      Normal (RG) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_MosTex(\"\tPremultiplied
      Metallic (R) Occlusion (G) Smoothness (B) Weight (A)\", 2D) = \"black\" {}\n\t[NoScaleOffset]_EmissionTex(\"\tPremultiplied
      Emission (RGB) Weight (A)\", 2D) = \"black\" {}\n\n\n\n\n    [Header(UNITY
      FOG)]\n    [Toggle(DISABLEFOG)] _CW_DisableFog(\"\tDisable\", Float) = 0\n\n\n\t[Header(HDRP
      Options)]\n\t[ToggleOff(_TRANSPARENT_WRITES_MOTION_VEC)] _CW_DisableTransparentMV(\"\tDisable
      Transparent Write Motion Vector\", Float) = 0\n\t[ToggleOff(_ENABLE_FOG_ON_TRANSPARENT)]
      _CW_DisableTransparentFog(\"\tDisable Transparent Fog\", Float) = 0\n\t[Toggle(_ADD_PRECOMPUTED_VELOCITY)]
      _CW_AddPrecomputedVelocity(\"\tAdd Precomputed Velocity\", Float) = 0\n\t[Toggle(_DISABLE_DECALS)]
      _CW_DisableDecals(\"\tDisable Decals\", Float) = 0\n\t[Toggle(_DISABLE_SSR)]
      _CW_DisableSSR(\"\tDisable SSR\", Float) = 0\n\t[Toggle(_DISABLE_SSR_TRANSPARENT)]
      _CW_DisableSSRTransparent(\"\tDisable Transparent SSR\", Float) = 0\n\t[KeywordEnum(Off,
      Plane, Sphere, Thin)] _CW_Refraction (\"\tRefraction\", Float) = 0 \n\n\n\n     
      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\",
      Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n     
      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\",
      Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\",
      Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n     
      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) =
      1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float)
      = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\",
      Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int)
      = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\",
      Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float)
      = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\",
      Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\",
      Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float)
      = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\",
      Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n     
      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\",
      Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n     
      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\",
      Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) =
      14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\",
      Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float)
      = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\",
      Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\",
      2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\",
      2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"
      = \"HDRenderPipeline\" \"RenderType\"=\"Transparent\" \"Queue\"=\"Transparent\"
      }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n           
      Blend SrcAlpha OneMinusSrcAlpha, One OneMinusSrcAlpha\nCull Back\n ZTest LEqual\nZWrite
      Off\n            \n            Stencil\n            {\n               WriteMask
      [_StencilWriteMask]\n               Ref [_StencilRef]\n               CompFront
      Always\n               PassFront Replace\n               CompBack Always\n              
      PassBack Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel]
      1\n\n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n\n\n           
      //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma
      shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile
      _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n           
      //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local
      _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n           
      #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment
      PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile_raytracing
      PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile
      _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n           
      #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK\n            #pragma
      multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma
      multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n            #pragma multi_compile_fragment
      SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH SHADOW_VERY_HIGH\n            #pragma
      multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n           
      #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n               
      \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n           
      //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n           
      #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n           
      #define _PASSFORWARD 1\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n\n\n           
      \n            \n            // data describing the user output of a pixel\n           
      struct Surface\n            {\n               half3 Albedo;\n              
      half Height;\n               half3 Normal;\n               half Smoothness;\n              
      half3 Emission;\n               half Metallic;\n               half3 Specular;\n              
      half Occlusion;\n               half SpecularPower; // for simple lighting\n              
      half Alpha;\n               float outputDepth; // if written, SV_Depth semantic
      is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n              
      half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET
      SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n           
      #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n\n         
      void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                 
      out float4 outColor : SV_Target0,  // outSpecularLighting\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback
      : VT_BUFFER_TARGET,\n                  #endif\n                  out float4
      outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n             
      #else\n                  out float4 outColor : SV_Target0\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback
      : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                    
      , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif //
      _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n             
      #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n             
      #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n             
      #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                
      // Init outMotionVector here to solve compiler warning (potentially unitialized
      variable)\n                 // It is init to the value of forceNoMotion (with
      2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n             
      #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n             
      FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt
      the SS position as our screen space positions are for a low res buffer, but
      we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering
      > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n             
      uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n             
      // input.positionSS is SV_Position\n              PositionInputs posInput =
      GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w,
      input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n             
      SurfaceData surfaceData;\n              BuiltinData builtinData;\n             
      Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n            \n\n             
      BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n             
      PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n             
      outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip
      lighting when doing debug pass because the debug pass is done before lighting
      so some buffers may not be properly initialized potentially causing crashes
      on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug
      display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                   
      outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData,
      posInput.positionSS, outSSSBuffer);\n                #endif\n\n             
      \n\n              // Same code in ShaderPassForwardUnlit.shader\n             
      // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size
      used in the buffer\n              //   i>0  -> the index used (0 value means
      nothing)\n              // The index stored in this buffer could either be\n             
      //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only
      one supported)\n              //   - a property index which is different for
      each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n             
      bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n             
      if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB
      = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                 
      // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug
      will do nothing if the index is not a known one\n                  for (int
      index = 1; index <= bufferSize; index++)\n                  {\n                     
      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                     
      // skip if not really in use\n                      if (indexMaterialProperty
      != 0)\n                      {\n                          viewMaterial = true;\n\n                         
      GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                         
      GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                         
      GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                         
      GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                         
      GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                     
      }\n                  }\n\n                  // TEMP!\n                  //
      For now, the final blit in the backbuffer performs an sRGB write\n                 
      // So in the meantime we apply the inverse transform to linear data to compensate.\n                 
      if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0,
      result));\n\n                  outColor = float4(result, 1.0);\n             
      }\n\n              if (!viewMaterial)\n              {\n                  if
      (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode
      == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                     
      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData,
      result);\n\n                      outColor = float4(result, 1.0f);\n                 
      }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                 
      {\n                      float4 result = _DebugTransparencyOverdrawWeight *
      float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST,
      TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                 
      }\n                  else\n          #endif\n                  {\n         
      #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags =
      LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                     
      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                     
      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput,
      preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                     
      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                     
      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                     
      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting
      *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                     
      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                     
      {\n                          outColor = float4(specularLighting, 1.0);\n                         
      outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                     
      }\n                      else\n                      {\n                         
      outColor = float4(diffuseLighting + specularLighting, 1.0);\n                         
      outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData,
      posInput.positionSS, outSSSBuffer);\n          #else\n                     
      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                     
      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n         
      #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef
      _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion
      = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec
      is already initialize at the value of forceNoMotion (see above)\n                     
      if (!forceNoMotion)\n                      {\n                          float2
      motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                         
      EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                         
      outMotionVec.zw = 1.0;\n                      }\n          #endif\n                 
      }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n         
      #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n         
      #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback
      = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n           
      ENDHLSL\n        }\n      \n      \n      \n      \n              Pass\n       
      {\n            // based on HDLitPass.template\n            Name \"META\"\n           
      Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n       
      \n            \n        \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n       
      \n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local
      _ _ALPHATEST_ON\n\n\n \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n           
      #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n           
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma shader_feature_local
      _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma
      shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local
      _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local
      _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN         \n\n\n   #define _HDRP 1\n#define
      _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n       
      \n\n            \n\n                  // useful conversion functions to make
      surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n\n  \n            \n            \n            // data describing the user
      output of a pixel\n            struct Surface\n            {\n              
      half3 Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                 
      , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n           
      {\n                FragInputs input = BuildFragInputs(v2f);\n\n               
      // input.positionSS is SV_Position\n                PositionInputs posInput
      = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z,
      input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n               
      SurfaceData surfaceData;\n                BuiltinData builtinData;\n               
      Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n                // no
      debug apply during light transport pass\n\n                BSDFData bsdfData
      = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n               
      LightTransportData lightTransportData = GetLightTransportData(surfaceData,
      builtinData, bsdfData);\n\n                // This shader is call two times.
      Once for getting emissiveColor, the other time to get diffuseColor\n               
      // We use unity_MetaFragmentControl to make the distinction.\n               
      float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n               
      {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                   
      // put abs here to silent a warning, no cost, no impact as color is assume
      to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor),
      saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n               
      }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                   
      // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n               
      }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n       
      }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n           
      Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\"
      }\n        \n            Cull Off\n            ColorMask 0\n\n            \n\n           
      HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma
      only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n           
      #pragma instancing_options renderinglayer\n        \n            //#pragma
      shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local
      _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local
      _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n            //-------------------------------------------------------------------------------------\n           
      // Variant Definitions (active field translations to HDRP defines)\n           
      //-------------------------------------------------------------------------------------\n           
      // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define
      _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY
      1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define
      _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT
      1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO
      1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n           
      // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR
      1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define
      _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n           
      // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n           
      // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n           
      // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON
      1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n           
      #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n           
      #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n           
      \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local
      _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma
      shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n   
      #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma shader_feature_local
      _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma
      shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local
      _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local
      _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE
      _REFRACTION_SPHERE _REFRACTION_THIN         \n\n\n   #define _HDRP 1\n#define
      _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT 1\n#define _USINGTEXCOORD1
      1\n\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n       
      \n            \n\n        \n                  // useful conversion functions
      to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name)
      TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n  \n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n        \n\n            \n            void Frag(  VertexToPixel IN\n           
      #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n               
      #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n               
      #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH
      is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth,
      but we still have normal buffer binded\n            , out float4 outNormalBuffer
      : SV_Target0\n            , out float1 depthColor : SV_Target1\n           
      #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n           
      #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth
      : SV_Depth\n            #endif\n            #if NEED_FACING\n              
      , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n            
      UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input
      = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n            
      PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw,
      input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n\n            
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n           
      SurfaceData surfaceData;\n            BuiltinData builtinData;\n           
      Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n            
      outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n            
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS,
      outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In
      case we are rendering in MSAA, reading the an MSAA depth buffer is way too
      expensive. To avoid that, we export the depth to a color buffer\n            
      depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH)
      // When we are MSAA depth only without normal buffer\n             // Due to
      the binding order of these two render targets, we need to have them both declared\n            
      outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are
      rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To
      avoid that, we export the depth to a color buffer\n             depthColor
      = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We
      use depth prepass for scene selection in the editor, this code allow to output
      the outline correctly\n             outColor = float4(_ObjectId, _PassValue,
      1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n       
      \n              Pass\n        {\n            Name \"ScenePickingPass\"\n           
      Tags\n            {\n               \"LightMode\" = \"Picking\"\n           
      }\n            \n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n           
      #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature
      _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF
      _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma
      shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local
      _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local
      _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _
      _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n           
      #pragma multi_compile _ WRITE_DECAL_BUFFER\n        \n\n            #define
      SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n           
      \n            \n   #pragma shader_feature_local _ _OVERRIDE_OPACITY\n   #pragma
      shader_feature_local _ _OVERRIDE_NORMAL\n   #pragma shader_feature_local _
      _OVERRIDE_MOS\n   #pragma shader_feature_local _ _OVERRIDE_EMISSION\n\n\n\t#define
      _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local DISABLEFOG    \n\n\n\t#pragma
      shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma shader_feature_local
      _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma
      shader_feature_local _DISABLE_DECALS\n\t#pragma shader_feature_local _DISABLE_SSR\n\t#pragma
      shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n   
      \n\n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n            void Frag( VertexToPixel v2f\n                         
      #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                         
      , out float4 outColor : SV_Target0\n                          #else\n                         
      #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color
      as SV_Target0 for alpha to coverage\n                            , out float4
      depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                               
      , out float4 outNormalBuffer : SV_Target1\n                               
      #endif\n                            #else\n                               
      #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer
      : SV_Target0\n                                #endif\n                           
      #endif\n\n                            // Decal buffer must be last as it is
      bind but we can optionally write into it (based on _DISABLE_DECALS)\n                           
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                           
      , out float4 outDecalBuffer : SV_TARGET_DECAL\n                           
      #endif\n                        #endif\n                        #if NEED_FACING\n                          
      , bool facing : SV_IsFrontFace\n                        #endif\n\n                     
      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                 
      FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS
      is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy,
      _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                 
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                 
      SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                 
      Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n\n                  \n                 
      #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for
      scene selection in the editor, this code allow to output the outline correctly\n                     
      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif
      defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                 
      #else\n                     #ifdef WRITE_MSAA_DEPTH\n                      
      // In case we are rendering in MSAA, reading the an MSAA depth buffer is way
      too expensive. To avoid that, we export the depth to a color buffer\n                      
      depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                         
      // Alpha channel is used for alpha to coverage\n                          depthColor.a
      = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                      
      #endif // alphatomask\n                     #endif // msaa_depth\n                 
      \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                       
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                    
      #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                       
      DecalPrepassData decalPrepassData;\n                        // We don't have
      the right to access SurfaceData in a shaderpass.\n                        //
      However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData()
      to every Material to return geomNormalWS anyway\n                        //
      Here we will put the constrain that any Material requiring to support Decal,
      will need to have geomNormalWS as member of surfaceData (and we already require
      normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                       
      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                       
      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                    
      #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n       
      }\n\n              Pass\n        {\n            Name \"MotionVectors\"\n           
      Tags\n            {\n               \"LightMode\" = \"MotionVectors\"\n           
      }\n    \n            // Render State\n            Cull Back\n            ZWrite
      On\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskMV]\n                 
      Ref [_StencilRefMV]\n                  CompFront Always\n                 
      PassFront Replace\n                  CompBack Always\n                  PassBack
      Replace\n               }\n\n            \n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n           
      #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n\n\n           
      #pragma multi_compile _ WRITE_MSAA_DEPTH\n            //#pragma shader_feature
      _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF
      _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma
      shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local
      _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local
      _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n           
      //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local
      _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n           
      #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //#pragma shader_feature_local
      _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n        \n\n            #define SHADERPASS SHADERPASS_MOTION_VECTORS\n           
      #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define VARYINGS_NEED_PASS\n           
      #define _PASSMOTIONVECTOR 1\n\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n#define
      SV_TARGET_NORMAL SV_Target3\n#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n#define
      SV_TARGET_NORMAL SV_Target2\n#else\n#define SV_TARGET_NORMAL SV_Target1\n#endif\n\n//
      Caution: Motion vector pass is different from Depth prepass, it render normal
      buffer last instead of decal buffer last\n// and thus, we force a write of
      0 if _DISABLE_DECALS so we always write in the decal buffer.\n// This is required
      as we can't make distinction  between deferred (write normal buffer) and forward
      (write normal buffer)\n// in the context of the motion vector pass. The cost
      is acceptable as it is only do object with motion vector (usualy skin object)\n//
      that most of the time use Forward Material (so are already writing motion vector
      data).\n// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)\nvoid
      Frag(  VertexToPixel v2f\n            #ifdef WRITE_MSAA_DEPTH\n           
      // We need the depth color as SV_Target0 for alpha to coverage\n           
      , out float4 depthColor : SV_Target0\n            , out float4 outMotionVector
      : SV_Target1\n                #ifdef WRITE_DECAL_BUFFER\n                ,
      out float4 outDecalBuffer : SV_Target2\n                #endif\n           
      #else\n            // When no MSAA, the motion vector is always the first buffer\n           
      , out float4 outMotionVector : SV_Target0\n                #ifdef WRITE_DECAL_BUFFER\n               
      , out float4 outDecalBuffer : SV_Target1\n                #endif\n           
      #endif\n\n            // Decal buffer must be last as it is bind but we can
      optionally write into it (based on _DISABLE_DECALS)\n            #ifdef WRITE_NORMAL_BUFFER\n           
      , out float4 outNormalBuffer : SV_TARGET_NORMAL\n            #endif\n\n           
      #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n           
      #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n           
      #endif\n        )\n          {\n\n              FragInputs input = BuildFragInputs(v2f);\n             
      PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw,
      input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n             
      float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n             
      SurfaceData surfaceData;\n              BuiltinData builtinData;\n             
      Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2f,
      input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                 
      , facing\n               #endif\n               );\n\n            #ifdef _DEPTHOFFSET_ON\n               
      v2f.motionVectorCS.w += builtinData.depthOffset;\n                v2f.previousPositionCS.w
      += builtinData.depthOffset;\n            #endif\n\n             // TODO: How
      to allow overriden motion vector from GetSurfaceAndBuiltinData ?\n            
      float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);\n\n            
      // Convert from Clip space (-1..1) to NDC 0..1 space.\n             // Note
      it doesn't mean we don't have negative value, we store negative or positive
      offset in NDC space.\n             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS
      * 0.5 + 0.5)) = (motionVector * 0.5)\n             EncodeMotionVector(motionVector
      * 0.5, outMotionVector);\n\n             // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n             bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n\n             // Setting the motionVector to a value more than 2
      set as a flag for \"force no motion\". This is valid because, given that the
      velocities are in NDC,\n             // a value of >1 can never happen naturally,
      unless explicitely set. \n             if (forceNoMotion)\n                
      outMotionVector = float4(2.0, 0.0, 0.0, 0.0);\n\n         // Depth and Alpha
      to coverage\n         #ifdef WRITE_MSAA_DEPTH\n             // In case we are
      rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To
      avoid that, we export the depth to a color buffer\n             depthColor
      = v2f.pos.z;\n\n             #ifdef _ALPHATOMASK_ON\n             // Alpha
      channel is used for alpha to coverage\n             depthColor.a = SharpenAlpha(builtinData.opacity,
      builtinData.alphaClipTreshold);\n             #endif\n         #endif\n\n        
      // Normal Buffer Processing\n         #ifdef WRITE_NORMAL_BUFFER\n            
      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n        
      #endif\n\n         #if defined(WRITE_DECAL_BUFFER)\n             DecalPrepassData
      decalPrepassData;\n             // Force a write in decal buffer even if decal
      is disab. This is a neutral value which have no impact for later pass\n            
      #ifdef _DISABLE_DECALS\n             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n            
      #else\n             // We don't have the right to access SurfaceData in a shaderpass.\n            
      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData()
      to every Material to return geomNormalWS anyway\n             // Here we will
      put the constrain that any Material requiring to support Decal, will need to
      have geomNormalWS as member of surfaceData (and we already require normalWS
      anyway)\n             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n            
      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n            
      #endif\n             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n        
      #endif\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n        
      #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n             
      Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n           
      {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n           
      // Render State\n            Cull Back\n            ZTest LEqual\n           
      ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n           
      // End Render Modes\n            //-------------------------------------------------------------------------------------\n       
      \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n           
      #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n\n\n           
      //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma
      shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n           
      //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma
      shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma
      shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local
      _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n           
      //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n               
      \n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n           
      #define _PASSFULLSCREENDEBUG 1\n            \n            \n   #pragma shader_feature_local
      _ _OVERRIDE_OPACITY\n   #pragma shader_feature_local _ _OVERRIDE_NORMAL\n  
      #pragma shader_feature_local _ _OVERRIDE_MOS\n   #pragma shader_feature_local
      _ _OVERRIDE_EMISSION\n\n\n\t#define _HAS_ALPHA_BLEND 1\n\n\n    #pragma shader_feature_local
      DISABLEFOG    \n\n\n\t#pragma shader_feature_local _ADD_PRECOMPUTED_VELOCITY\n\t#pragma
      shader_feature_local _TRANSPARENT_WRITES_MOTION_VEC\n\t#pragma shader_feature_local
      _ENABLE_FOG_ON_TRANSPARENT\n\t#pragma shader_feature_local _DISABLE_DECALS\n\t#pragma
      shader_feature_local _DISABLE_SSR\n\t#pragma shader_feature_local _DISABLE_SSR_TRANSPARENT\n\t#pragma
      shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN        
      \n\n\n   #define _HDRP 1\n#define _BLENDMODE_ALPHA 1\n#define _SURFACE_TYPE_TRANSPARENT
      1\n#define _USINGTEXCOORD1 1\n\n\n               #pragma vertex Vert\n   #pragma
      fragment Frag\n\n                  // useful conversion functions to make surface
      shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name)
      TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name);
      SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex)
      TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)           
      SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define
      UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex,
      sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex,
      coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define
      UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp,
      coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex,
      sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if
      defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name)
      name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n     
      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half
      sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data,
      normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal)
      mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"
      // Required to be include before we include properties as it define DECLARE_STACK_CB\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\"
      // Need to be here for Gradient struct definition\n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
      \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n   
      \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define
      RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n           
      // If we use subsurface scattering, enable output split lighting (for forward
      pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) &&
      !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n           
      #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS
      == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT)
      && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n              
      #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n              
      // In case of opaque we don't want to perform the alpha test, it is done in
      depth prepass and we use depth equal for ztest (setup from UI)\n              
      // Don't do it with debug display mode as it is possible there is no depth
      prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT)
      && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                 
      #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS
      == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                 
      #endif\n               #endif\n            #endif\n\n            // Define
      _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n           
      #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n              
      #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            //
      Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC)
      && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n           
      #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n              
      float _UseShadowThreshold;\n               float _BlendMode;\n              
      float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n              
      float _RefractionModel;\n\n              \n\tfloat4 _Color;\n\tfloat  _BumpScale;\n\tfloat 
      _Metallic;\n\tfloat  _GlossMapScale;\n\tfloat3 _Emission;\n\tfloat2 _Tiling;\n\tfloat 
      _UseUV2;\n\tfloat  _UseUV2Alt;\n\n\n\n\n\n\n\n\n\n            CBUFFER_END\n   
      \n\n\n             // -- Property used by ScenePickingPass\n              
      #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n              
      #endif\n    \n               // -- Properties used by SceneSelectionPass\n              
      #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int
      _PassValue;\n               #endif\n  \n           \n            // data across
      stages, stripped like the above.\n            struct VertexToPixel\n           
      {\n               float4 pos : SV_POSITION;\n               float3 worldPos
      : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n              
      float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n              
      float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n              
      // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n              
      // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               //
      float4 screenPos : TEXCOORD7;\n               // #endif\n\n               //
      #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n              
      // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n              
      // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n              
      // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                 
      uint instanceID : INSTANCEID_SEMANTIC;\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n              
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float4 previousPositionCS : TEXCOORD16; // Contain previous transform position
      (in case of skinning for example)\n                  float4 motionVectorCS
      : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n           
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n   
      \n\n            \n            \n            // data describing the user output
      of a pixel\n            struct Surface\n            {\n               half3
      Albedo;\n               half Height;\n               half3 Normal;\n              
      half Smoothness;\n               half3 Emission;\n               half Metallic;\n              
      half3 Specular;\n               half Occlusion;\n               half SpecularPower;
      // for simple lighting\n               half Alpha;\n               float outputDepth;
      // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n              
      // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n              
      half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n              
      half Anisotropy;\n               half IridescenceMask;\n               half
      IridescenceThickness;\n               int DiffusionProfileHash;\n              
      float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n              
      // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n              
      float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3
      SpecularGI;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n              
      float4 ShadowMask;\n            };\n\n            // Data the user declares
      in blackboard blocks\n            struct Blackboard\n            {\n               
      \n                float blackboardDummyData;\n            };\n\n           
      // data the user might need, this will grow to be big. But easy to strip\n           
      struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n              
      float3 localSpacePosition;\n               float3 localSpaceNormal;\n              
      float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n              
      float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n              
      float tangentSign;\n\n               float3 worldSpaceViewDir;\n              
      float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n              
      float4 texcoord1;\n               float4 texcoord2;\n               float4
      texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n              
      float4 vertexColor;\n               bool isFrontFace;\n\n               float4
      extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n              
      float4 extraV2F3;\n               float4 extraV2F4;\n               float4
      extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n              
      float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n           
      struct VertexData\n            {\n               #if SHADER_TARGET > 30\n              
      // uint vertexID : SV_VertexID;\n               #endif\n               float4
      vertex : POSITION;\n               float3 normal : NORMAL;\n              
      float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n              
      // optimize out mesh coords when not in use by user or lighting system\n              
      #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if
      _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) &&
      defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n              
      #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA ||
      ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                 
      float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD
      && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                 
      float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if
      _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4
      texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD4; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic
      computes velocities on runtime side).\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n           
      struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n              
      float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n              
      float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n              
      float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n              
      // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n              
      // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n              
      // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               //
      float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               //
      #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n              
      // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n              
      // #endif\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD
      || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                 
      float3 previousPositionOS : TEXCOORD13; // Contain previous transform position
      (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                    
      float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n              
      #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n           
      };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n              
      float4 extraV2F1;\n               float4 extraV2F2;\n               float4
      extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n              
      float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard
      blackboard;\n               float4 time;\n            };\n\n\n            float3
      WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n              
      return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData
      d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n           
      }\n\n            // in this case, make standard more like SRPs, because we
      can't fix\n            // unity_WorldToObject in HDRP, since it already does
      macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3
      p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3
      TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p,
      1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject,
      p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld,
      p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject;
      }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld;
      }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE)
      || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS
      && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,
      lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,
      lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                
      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                
      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n             
      #endif\n\n               #undef GetObjectToWorldMatrix()\n               #undef
      GetWorldToObjectMatrix()\n               #undef GetWorldToViewMatrix()\n              
      #undef UNITY_MATRIX_I_V\n               #undef UNITY_MATRIX_P\n              
      #undef GetWorldToHClipMatrix()\n               #undef GetObjectToWorldMatrix()V\n              
      #undef UNITY_MATRIX_T_MV\n               #undef UNITY_MATRIX_IT_MV\n              
      #undef GetObjectToWorldMatrix()VP\n\n               #define GetObjectToWorldMatrix()    
      unity_ObjectToWorld\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n              
      #define GetWorldToViewMatrix()     unity_MatrixV\n               #define UNITY_MATRIX_I_V  
      unity_MatrixInvV\n               #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(glstate_matrix_projection)\n              
      #define GetWorldToHClipMatrix()    unity_MatrixVP\n               #define GetObjectToWorldMatrix()V   
      mul(GetWorldToViewMatrix(), GetObjectToWorldMatrix())\n               #define
      UNITY_MATRIX_T_MV  transpose(GetObjectToWorldMatrix()V)\n               #define
      UNITY_MATRIX_IT_MV transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V))\n              
      #define GetObjectToWorldMatrix()VP   mul(GetWorldToHClipMatrix(), GetObjectToWorldMatrix())\n\n\n           
      #endif\n\n            float3 GetCameraWorldPosition()\n            {\n              
      #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n              
      #else\n                  return _WorldSpaceCameraPos;\n               #endif\n           
      }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                 
      TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n              
      #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                 
      #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%,
      sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                    
      return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n              
      }\n            #endif\n\n\n      \n            #if _STANDARD\n              
      UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2
      uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n              
      float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv));
      }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv));
      } \n            #else\n               float GetSceneDepth(float2 uv) { return
      SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2
      uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n              
      float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv),
      _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2
      uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n              
      float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(),
      UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir,
      camView);\n               float3 div = worldSpaceViewDir/dt;\n              
      float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return
      wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n           
      }\n            #else\n            float3 ObjectToWorldSpacePosition(float3
      pos)\n            {\n               return TransformObjectToWorld(pos);\n           
      }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n              
      float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture,
      uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                 
      norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                 
      return norms;\n               }\n            #elif _HDRP\n               float3
      GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                 
      NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv,
      nd);\n                  return nd.normalWS;\n               }\n           
      #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                 
      #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n              
      #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n              
      {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                    
      return SampleSceneNormals(uv);\n                  #else\n                    
      float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                    
      return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                 
      #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n              
      half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                    
      // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                 
      half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                 
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                 
      return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n              
      {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return
      packednormal.xyz * 2 - 1;\n                  #else\n                     return
      UnpackNormalmapRGorAG(packednormal);\n                  #endif\n              
      }\n               #endif\n               #if _HDRP || _URP\n\n              
      half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                
      #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1,
      y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like
      \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                  
      packednormal.x *= packednormal.w;\n                 #endif\n                  
      half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                  
      normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  
      return normal;\n               }\t\n\n             #endif\n\n\n           
      void GetSun(out float3 lightDir, out float3 color)\n            {\n              
      lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n              
      #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                 
      {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                    
      lightDir = -light.forward.xyz;\n                     color = light.color;\n                 
      }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                 
      color = _LightColor0.rgb;\n               #elif _URP\n\t               Light
      light = GetMainLight();\n\t               lightDir = light.direction;\n\t              
      color = light.color;\n               #endif\n            }\n\n\n\n           
      \n\n            \n\n            #ifdef unity_WorldToObject\n#undef unity_WorldToObject\n#endif\n#ifdef
      unity_ObjectToWorld\n#undef unity_ObjectToWorld\n#endif\n#define unity_ObjectToWorld
      GetObjectToWorldMatrix()\n#define unity_WorldToObject GetWorldToObjectMatrix()\n\n\tTEXTURE2D(_MainTex);\n\tSAMPLER(sampler_MainTex);\n\tTEXTURE2D(_BumpMap);\n\tSAMPLER(sampler_BumpMap);\n\tTEXTURE2D(_MetallicGlossMap);\n\tSAMPLER(sampler_MetallicGlossMap);\n\tTEXTURE2D(_EmissionMap);\n\tSAMPLER(sampler_EmissionMap);\n\n\tTEXTURE2D(_AlbedoTex);\n\tSAMPLER(sampler_AlbedoTex);\n\tTEXTURE2D(_OpacityTex);\n\tSAMPLER(sampler_OpacityTex);\n\tTEXTURE2D(_NormalTex);\n\tSAMPLER(sampler_NormalTex);\n\tTEXTURE2D(_EmissionTex);\n\tSAMPLER(sampler_EmissionTex);\n\tTEXTURE2D(_MosTex);\n\tSAMPLER(sampler_MosTex);\n\n\tvoid
      Ext_ModifyVertex0 (inout VertexData v, inout ExtraV2F d)\n\t{\n\t\tfloat4 first 
      = lerp(v.texcoord0, v.texcoord1, _UseUV2);\n\t\tfloat4 second = lerp(v.texcoord0,
      v.texcoord1, _UseUV2Alt);\n\n\t\tv.texcoord0.xy =  first.xy * _Tiling;\n\t\tv.texcoord1.xy
      = second.xy;\n\t}\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData
      d)\n\t{\n\t\tfloat4 texMain = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, d.texcoord0);\n\t\tfloat4
      gloss   = SAMPLE_TEXTURE2D(_MetallicGlossMap, sampler_MetallicGlossMap, d.texcoord0);\n\t\tfloat4
      bump    = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap, d.texcoord0);\n\t\tfloat4
      glow    = SAMPLE_TEXTURE2D(_EmissionMap, sampler_EmissionMap, d.texcoord0);\n\n\t\to.Albedo    
      = texMain.rgb * _Color.rgb;\n\t\to.Normal     = UnpackScaleNormal(bump, _BumpScale);\n\t\to.Metallic  
      = gloss.r * _Metallic;\n\t\to.Occlusion  = gloss.g;\n\t\to.Smoothness = gloss.b
      * _GlossMapScale;\n\t\to.Emission   = glow.rgb * _Emission;\n\t\to.Alpha     
      = texMain.a * _Color.a;\n\n\t\t// Override albedo?\n\t\tfloat4 albedo = SAMPLE_TEXTURE2D(_AlbedoTex,
      sampler_AlbedoTex, d.texcoord1);\n\t\to.Albedo = (1.0f - albedo.a) * o.Albedo
      + albedo.rgb;\n\n\t#if _OVERRIDE_OPACITY\n\t\tfloat4 opacity = SAMPLE_TEXTURE2D(_OpacityTex,
      sampler_OpacityTex, d.texcoord1);\n\t\to.Alpha = (1.0f - opacity.a) * o.Alpha
      + opacity.r;\n\t#endif\n\n\t#if !_HAS_ALPHA_BLEND\n\t\tclip(o.Alpha - 0.5f);\n\t#endif\n\n\t#if
      _OVERRIDE_NORMAL\n\t\tfloat4 normal = SAMPLE_TEXTURE2D(_NormalTex, sampler_NormalTex,
      d.texcoord1);\n\t\to.Normal = (1.0f - normal.a) * o.Normal + normal.r;\n\t#endif\n\t\n\t#if
      _OVERRIDE_MOS\n\t\tfloat4 mos = SAMPLE_TEXTURE2D(_MosTex, sampler_MosTex, d.texcoord1);\n\t\to.Metallic  
      = (1.0f - mos.a) * o.Metallic + mos.r;\n\t\to.Occlusion  = (1.0f - mos.a) *
      o.Metallic + mos.g;\n\t\to.Smoothness = (1.0f - mos.a) * o.Metallic + mos.b;\n\t#endif\n\t\n\t#if
      _OVERRIDE_EMISSION\n\t\tfloat4 emission = SAMPLE_TEXTURE2D(_EmissionTex, sampler_EmissionTex,
      d.texcoord1);\n\t\to.Emission = (1.0f - emission.a) * o.Emission + emission.rgb;\n\t#endif\n\t}\n\n\n\n\n\n\n\n\n\n       
      \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n           
      {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l,
      d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l,
      d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l,
      d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l,
      d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l,
      d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l,
      d);\n                 // Ext_SurfaceFunction12(l, d);\n                 //
      Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l,
      d);\n                 // Ext_SurfaceFunction15(l, d);\n                 //
      Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l,
      d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l,
      d);\n                 // Ext_SurfaceFunction20(l, d);\n                 //
      Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l,
      d);\n                 // Ext_SurfaceFunction23(l, d);\n                 //
      Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l,
      d);\n                 // Ext_SurfaceFunction26(l, d);\n                 //
      Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l,
      d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n           
      void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4
      time)\n            {\n                 ExtraV2F d;\n                 \n                
      ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard,
      d.blackboard);\n                 // due to motion vectors in HDRP, we need
      to use the last\n                 // time in certain spots. So if you are going
      to use _Time to adjust vertices,\n                 // you need to use this
      time or motion vectors will break. \n                 d.time = time;\n\n                  
      Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                
      // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                
      // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                
      // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                
      // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                
      // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                
      // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                
      // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                
      // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                
      // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                
      // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                
      // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                
      // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                
      // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                
      // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                
      // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                
      // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                
      // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                
      // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                
      // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                
      // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                
      // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                
      // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                
      // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                
      // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                
      // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                
      // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n           
      void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n           
      {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n              
      ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n              
      // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n              
      // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n              
      // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               //
      d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               //
      #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n              
      // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               //
      d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               //
      #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n              
      // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               //
      d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               //
      #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n              
      // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n              
      // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v,
      d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n              
      // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v,
      d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n              
      // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v,
      d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n              
      // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v,
      d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n              
      // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v,
      d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n              
      // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v,
      d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n              
      // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v,
      d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n              
      // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v,
      d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n              
      // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v,
      d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n              
      // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v,
      d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0
      = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n              
      // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n              
      // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n              
      // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               //
      v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               //
      #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n              
      // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               //
      v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               //
      #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n              
      // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               //
      v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n           
      void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4
      color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n              
      //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l,
      d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n              
      //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l,
      d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n              
      //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l,
      d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n              
      //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l,
      d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n              
      //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l,
      d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n              
      //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l,
      d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n              
      //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l,
      d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n              
      //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l,
      d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n              
      //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l,
      d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n              
      //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l,
      d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout
      Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1,
      inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n           
      {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1,
      GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0,
      GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s,
      d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n              
      //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission,
      outShadowMask);\n            }\n\n\n\n            \n\n         ShaderData CreateShaderData(VertexToPixel
      i\n                  #if NEED_FACING\n                     , bool facing\n                 
      #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n           
      d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n           
      d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent
      = normalize(i.worldTangent.xyz);\n            d.tangentSign = i.worldTangent.w;\n           
      float3 bitangent = cross(i.worldTangent.xyz, i.worldNormal) * d.tangentSign
      * -1;\n            \n\n            d.TBNMatrix = float3x3(d.worldSpaceTangent,
      bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos
      - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n            
      d.texcoord0 = i.texcoord0;\n             d.texcoord1 = i.texcoord1;\n           
      // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n           
      // d.texcoord3 = i.texcoord3;\n            // #endif\n\n            // d.isFrontFace
      = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor
      = i.vertexColor;\n            // #endif\n\n            // these rarely get
      used, so we back transform them. Usually will be stripped.\n            #if
      _HDRP\n                // d.localSpacePosition = mul(unity_WorldToObject, float4(GetCameraRelativePositionWS(i.worldPos),
      1)).xyz;\n            #else\n                // d.localSpacePosition = mul(unity_WorldToObject,
      float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal
      = normalize(mul((float3x3)unity_WorldToObject, i.worldNormal));\n           
      // d.localSpaceTangent = normalize(mul((float3x3)unity_WorldToObject, i.worldTangent.xyz));\n\n           
      // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n           
      // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n           
      // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n           
      // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1
      = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n           
      // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if
      %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n           
      // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4
      = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n           
      // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if
      %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n           
      // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7
      = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n        
      \n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   //
      This was not in constant buffer in original unity, so keep outiside. But should
      be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n  
      float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use
      uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n  
      // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n  
      CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n      
      UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n      
      if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy
      * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n      
      {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n      
      }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n      
      // so we create a fake dependency on it here that haven't any impact.\n      
      output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0,
      1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n      
      // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n      
      // Not required but assign to silent compiler warning\n       output.worldTangent
      = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n      
      output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n      
      // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n  
      #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n     
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n     
      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n         
      input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n         
      input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n     
      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel
      output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n      
      UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n      
      #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n        
      VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input,
      output, _Time);\n\n       // This return the camera relative position (if enable)\n      
      float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3
      normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS
      = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n      
      output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos =
      TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n      
      output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n      
      output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n      
      // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n      
      // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor
      = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n      
      // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n      
      // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD ||
      _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if
      !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n         
      #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP,
      float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y
      is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y
      == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS
      = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n           
      bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n           
      float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS
      : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n              
      effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n           
      previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel
      dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh,
      dummy, _LastTimeParameters);\n\n            // we might need this for skinned
      objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n           
      float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n           
      #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors
      > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n           
      }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS
      = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n      
      #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n      
      return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n              
      #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                 
      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n              
      #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n               
      {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                   
      FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n           
      \n                    // Init to some default value to make the computer quiet
      (else it output 'divide by zero' warning even if value is not used).\n                   
      // TODO: this is a really poor workaround, but the variable is used in a bunch
      of places\n                    // to compute normals which are then passed
      on elsewhere to compute other values...\n                    output.tangentToWorld
      = k_identity3x3;\n                    output.positionSS = input.pos;      
      // input.positionCS is SV_Position\n                    // BETTER SHADERS:
      because we transform world position into actual world space for things like\n                   
      // triplanar, etc, we have to back transform it here for lighting\n                   
      output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                   
      output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                   
      output.texCoord0 = input.texcoord0;\n                    output.texCoord1 =
      input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n           
      \n                    return output;\n                }\n            \n              
      void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription,
      float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3
      bentNormalWS)\n               {\n                   // setup defaults -- these
      are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData,
      surfaceData);\n        \n                   // specularOcclusion need to be
      init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                  
      // however specularOcclusion can come from the graph, so need to be init here
      so it can be override.\n                   surfaceData.specularOcclusion =
      1.0;\n\n                   // copy across graph values, if defined\n                  
      surfaceData.baseColor =                 surfaceDescription.Albedo;\n                  
      surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                  
      surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                  
      surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                  
      surfaceData.metallic =                  surfaceDescription.Metallic;\n                  
      surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                  
      surfaceData.thickness =                 surfaceDescription.Thickness;\n                  
      surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                  
      #if _USESPECULAR\n                      surfaceData.specularColor =            
      surfaceDescription.Specular;\n                   #endif\n                  
      surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                  
      surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                  
      surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                  
      surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                  
      #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                       
      if (_EnableSSRefraction)\n                        {\n                           
      surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                           
      surfaceDescription.Alpha = 1.0;\n                        }\n                       
      else\n                        {\n                            surfaceData.ior
      = 1.0;\n                            surfaceData.transmittanceColor = float3(1.0,
      1.0, 1.0);\n                            surfaceData.atDistance = 1.0;\n                           
      surfaceData.transmittanceMask = 0.0;\n                            surfaceDescription.Alpha
      = 1.0;\n                        }\n                    #else\n                       
      surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor
      = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance =
      1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                   
      #endif\n\n                    \n\n                    // These static material
      feature allow compile time optimization\n                    surfaceData.materialFeatures
      = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                       
      surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n               
      \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                   
      #endif\n                \n                    #ifdef _MATERIAL_FEATURE_CLEAR_COAT\n                       
      surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                   
      #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR)
      && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require
      to have setup baseColor\n                        // Reproduce the energy conservation
      done in legacy Unity. Not ideal but better for compatibility and users can
      unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r,
      surfaceData.specularColor.g, surfaceData.specularColor.b));\n                   
      #endif\n                \n\n\n                   // compute world space normal\n                  
      #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal,
      fragInputs.tangentToWorld);\n                   #else\n                     
      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                  
      surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                  
      surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    //
      The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it
      expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                   
      #if HAVE_DECALS\n                        if (_EnableDecals)\n                       
      {\n                            float alpha = 1.0;\n                           
      alpha = surfaceDescription.Alpha;\n                \n                           
      // Both uses and modifies 'surfaceData.normalWS'.\n                           
      DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2],
      alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData,
      fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                   
      #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n               
      \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS,
      surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                       
      if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                           
      // TODO: need to update mip info\n                            surfaceData.metallic
      = 0;\n                        }\n                \n                       
      // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and
      before filling builtinData\n                        // as it can modify attribute
      use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld,
      surfaceData);\n                    #endif\n                \n                   
      // By default we use the ambient occlusion with Tri-ace trick (apply outside)
      for specular occlusion.\n                    // If user provide bent normal
      then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                       
      // Just use the value passed through via the slot (not active otherwise)\n                   
      #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                       
      // If we have bent normal and ambient occlusion, process a specular occlusion\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS,
      surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                   
      #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                       
      surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS,
      V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                   
      #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA)
      && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness
      = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2],
      surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                   
      #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel
      m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                    
      out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l,
      inout ShaderData d\n                     #if NEED_FACING\n                       
      , bool facing\n                     #endif\n                  )\n              
      {\n                 // Removed since crossfade does not work, probably needs
      extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING)
      && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE
      // enable dithering LOD transition if user select CrossFade transition in LOD
      group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V,
      posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                
      //#endif\n\n                 d = CreateShaderData(m2ps\n                   
      #if NEED_FACING\n                       , facing\n                    #endif\n                
      );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5,
      0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion
      = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion =
      1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l,
      d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                   
      //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                
      #if _UNLIT\n                     //l.Emission = l.Albedo;\n                    
      //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                    
      l.Occlusion = 1;\n                     l.Metallic = 0;\n                    
      l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS
      = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                
      fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                
      BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                
      InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1,
      fragInputs.texCoord2, builtinData);\n\n                 \n\n                
      builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                   
      builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting
      = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                
      #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                   
      builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1
      = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                   
      builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 
      #ifdef UNITY_VIRTUAL_TEXTURING\n                     builtinData.vtPackedFeedback
      = surfaceDescription.VTPackedFeedback;\n                  #endif\n\n                 
      #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion
      = surfaceData.Distortion;\n                     builtinData.distortionBlur
      = surfaceData.DistortionBlur;\n                  #endif\n\n                 
      #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                   
      PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                 
      #else\n                    ApplyDebugToBuiltinData(builtinData);\n                 
      #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n              
      }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include
      \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n        
      #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading
      debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel
      v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n           
      #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n            
      FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput
      = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z,
      input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n            
      if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n            
      {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n            
      }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n\n\n\n\n\n\n     
      \n   }\n\n   \n   \n   \n}\n"
    Hash: -395843100
    Dirty: 0
